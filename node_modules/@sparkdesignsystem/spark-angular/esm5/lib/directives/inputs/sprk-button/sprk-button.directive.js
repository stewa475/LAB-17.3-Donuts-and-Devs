import { __decorate, __metadata } from "tslib";
import { Directive, ElementRef, OnInit, Input, HostBinding, OnChanges, Renderer2, AfterViewInit, SimpleChanges, } from '@angular/core';
var SprkButtonDirective = /** @class */ (function () {
    /**
     * @ignore
     */
    function SprkButtonDirective(ref, renderer) {
        var _this = this;
        this.ref = ref;
        this.renderer = renderer;
        /**
         * Will show a spinner inside the
         * button if set to `true`.
         */
        this.isSpinning = false;
        /**
         * Optional string value that is
         * set for the `aria-label`
         * when `isSpinning` is `true`.
         */
        this.spinningAriaLabel = 'Loading';
        /**
         *  Determines the coresponding button style.
         */
        this.variant = 'primary';
        /**
         * @ignore
         */
        this.setSpinning = function (element) {
            var el = element;
            var width = element.offsetWidth;
            var ariaLabel = _this.spinningAriaLabel;
            var spinnerClass = 'sprk-c-Spinner sprk-c-Spinner--circle';
            if (el.classList.contains('sprk-c-Button--secondary') ||
                _this.variant === 'secondary') {
                spinnerClass += ' sprk-c-Spinner--dark';
            }
            _this.renderer.setAttribute(el, 'data-sprk-spinner-text', el.textContent);
            _this.renderer.setAttribute(el, 'aria-label', ariaLabel);
            el.innerHTML = "<div class=\"" + spinnerClass + "\"></div>";
            el.setAttribute('data-sprk-has-spinner', 'true');
            _this.renderer.setAttribute(el, 'data-sprk-has-spinner', 'true');
            _this.renderer.setAttribute(el, 'style', "width: " + width + "px");
        };
    }
    SprkButtonDirective.prototype.ngOnInit = function () {
        if (this.variant === 'secondary') {
            this.renderer.addClass(this.ref.nativeElement, 'sprk-c-Button--secondary');
        }
        if (this.variant === 'tertiary') {
            this.renderer.addClass(this.ref.nativeElement, 'sprk-c-Button--tertiary');
        }
    };
    /**
     * Add spinner only after view has loaded.
     * This is to allow time for the text
     * content of the button to load so that
     * the width value accounts for that text.
     */
    SprkButtonDirective.prototype.ngAfterViewInit = function () {
        if (this.isSpinning) {
            this.setSpinning(this.ref.nativeElement);
        }
    };
    SprkButtonDirective.prototype.ngOnChanges = function (changes) {
        if (this.isSpinning && !changes['isSpinning'].isFirstChange()) {
            this.setSpinning(this.ref.nativeElement);
        }
    };
    SprkButtonDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SprkButtonDirective.prototype, "isSpinning", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SprkButtonDirective.prototype, "spinningAriaLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SprkButtonDirective.prototype, "variant", void 0);
    __decorate([
        HostBinding('class.sprk-c-Button'),
        __metadata("design:type", Object)
    ], SprkButtonDirective.prototype, "true", void 0);
    __decorate([
        HostBinding('attr.data-id'),
        Input(),
        __metadata("design:type", String)
    ], SprkButtonDirective.prototype, "idString", void 0);
    __decorate([
        HostBinding('attr.data-analytics'),
        Input(),
        __metadata("design:type", String)
    ], SprkButtonDirective.prototype, "analyticsString", void 0);
    SprkButtonDirective = __decorate([
        Directive({
            selector: '[sprkButton]'
        }),
        __metadata("design:paramtypes", [ElementRef, Renderer2])
    ], SprkButtonDirective);
    return SprkButtonDirective;
}());
export { SprkButtonDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Byay1idXR0b24uZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJrZGVzaWduc3lzdGVtL3NwYXJrLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9pbnB1dHMvc3Byay1idXR0b24vc3Byay1idXR0b24uZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUNMLFdBQVcsRUFDWCxTQUFTLEVBQ1QsU0FBUyxFQUNULGFBQWEsRUFDYixhQUFhLEdBQ2QsTUFBTSxlQUFlLENBQUM7QUFLdkI7SUFDRTs7T0FFRztJQUNILDZCQUFtQixHQUFlLEVBQVUsUUFBbUI7UUFBL0QsaUJBQW1FO1FBQWhELFFBQUcsR0FBSCxHQUFHLENBQVk7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBRS9EOzs7V0FHRztRQUNNLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFFNUI7Ozs7V0FJRztRQUNNLHNCQUFpQixHQUFHLFNBQVMsQ0FBQztRQUV2Qzs7V0FFRztRQUNNLFlBQU8sR0FBd0MsU0FBUyxDQUFDO1FBMERsRTs7V0FFRztRQUNILGdCQUFXLEdBQUcsVUFBQyxPQUFPO1lBQ3BCLElBQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQztZQUNuQixJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDO1lBQ2xDLElBQU0sU0FBUyxHQUFHLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQztZQUN6QyxJQUFJLFlBQVksR0FBRyx1Q0FBdUMsQ0FBQztZQUMzRCxJQUNJLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLDBCQUEwQixDQUFDO2dCQUNqRCxLQUFJLENBQUMsT0FBTyxLQUFLLFdBQVcsRUFBRTtnQkFDaEMsWUFBWSxJQUFJLHVCQUF1QixDQUFDO2FBQ3pDO1lBQ0QsS0FBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQ3hCLEVBQUUsRUFDRix3QkFBd0IsRUFDeEIsRUFBRSxDQUFDLFdBQVcsQ0FDZixDQUFDO1lBQ0YsS0FBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQ3hCLEVBQUUsRUFDRixZQUFZLEVBQ1osU0FBUyxDQUNWLENBQUM7WUFDRixFQUFFLENBQUMsU0FBUyxHQUFHLGtCQUFlLFlBQVksY0FBVSxDQUFDO1lBQ3JELEVBQUUsQ0FBQyxZQUFZLENBQUMsdUJBQXVCLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDakQsS0FBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQ3hCLEVBQUUsRUFDRix1QkFBdUIsRUFDdkIsTUFBTSxDQUNQLENBQUM7WUFDRixLQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FDeEIsRUFBRSxFQUNGLE9BQU8sRUFDUCxZQUFVLEtBQUssT0FBSSxDQUNwQixDQUFDO1FBQ0osQ0FBQyxDQUFBO0lBL0dpRSxDQUFDO0lBMkNuRSxzQ0FBUSxHQUFSO1FBQ0UsSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLFdBQVcsRUFBRTtZQUNoQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FDcEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQ3RCLDBCQUEwQixDQUMzQixDQUFDO1NBQ0g7UUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssVUFBVSxFQUFFO1lBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUNwQixJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFDdEIseUJBQXlCLENBQzFCLENBQUM7U0FDSDtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDZDQUFlLEdBQWY7UUFDRSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDbkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQzFDO0lBQ0gsQ0FBQztJQUVELHlDQUFXLEdBQVgsVUFBWSxPQUFzQjtRQUNoQyxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsYUFBYSxFQUFFLEVBQUU7WUFDN0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQzFDO0lBQ0gsQ0FBQzs7Z0JBMUV1QixVQUFVO2dCQUFvQixTQUFTOztJQU10RDtRQUFSLEtBQUssRUFBRTs7MkRBQW9CO0lBT25CO1FBQVIsS0FBSyxFQUFFOztrRUFBK0I7SUFLOUI7UUFBUixLQUFLLEVBQUU7O3dEQUEwRDtJQUc5QjtRQUFuQyxXQUFXLENBQUMscUJBQXFCLENBQUM7O3FEQUFNO0lBV2hDO1FBRFIsV0FBVyxDQUFDLGNBQWMsQ0FBQztRQUMzQixLQUFLLEVBQUU7O3lEQUFrQjtJQVNqQjtRQURSLFdBQVcsQ0FBQyxxQkFBcUIsQ0FBQztRQUNsQyxLQUFLLEVBQUU7O2dFQUF5QjtJQTdDdEIsbUJBQW1CO1FBSC9CLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxjQUFjO1NBQ3pCLENBQUM7eUNBS3dCLFVBQVUsRUFBb0IsU0FBUztPQUpwRCxtQkFBbUIsQ0FvSC9CO0lBQUQsMEJBQUM7Q0FBQSxBQXBIRCxJQW9IQztTQXBIWSxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIE9uSW5pdCxcbiAgSW5wdXQsXG4gIEhvc3RCaW5kaW5nLFxuICBPbkNoYW5nZXMsXG4gIFJlbmRlcmVyMixcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgU2ltcGxlQ2hhbmdlcyxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tzcHJrQnV0dG9uXSdcbn0pXG5leHBvcnQgY2xhc3MgU3Bya0J1dHRvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0IHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICAvKipcbiAgICogV2lsbCBzaG93IGEgc3Bpbm5lciBpbnNpZGUgdGhlXG4gICAqIGJ1dHRvbiBpZiBzZXQgdG8gYHRydWVgLlxuICAgKi9cbiAgQElucHV0KCkgaXNTcGlubmluZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBzdHJpbmcgdmFsdWUgdGhhdCBpc1xuICAgKiBzZXQgZm9yIHRoZSBgYXJpYS1sYWJlbGBcbiAgICogd2hlbiBgaXNTcGlubmluZ2AgaXMgYHRydWVgLlxuICAgKi9cbiAgQElucHV0KCkgc3Bpbm5pbmdBcmlhTGFiZWwgPSAnTG9hZGluZyc7XG5cbiAgLyoqXG4gICAqICBEZXRlcm1pbmVzIHRoZSBjb3Jlc3BvbmRpbmcgYnV0dG9uIHN0eWxlLlxuICAgKi9cbiAgQElucHV0KCkgdmFyaWFudDogJ3ByaW1hcnknfCAnc2Vjb25kYXJ5JyB8ICd0ZXJ0aWFyeScgPSAncHJpbWFyeSc7XG5cbiAgLy8gQWx3YXlzIHNldCB0aGUgYnV0dG9uIGNsYXNzIG9uIHRoZSBlbGVtZW50XG4gIEBIb3N0QmluZGluZygnY2xhc3Muc3Byay1jLUJ1dHRvbicpIHRydWU7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBzdXBwbGllZCB3aWxsIGJlIGFzc2lnbmVkXG4gICAqIHRvIHRoZSBgZGF0YS1pZGAgYXR0cmlidXRlIG9uIHRoZVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAgICogdXNlZCBhcyBhIHNlbGVjdG9yIGZvciBhdXRvbWF0ZWRcbiAgICogdG9vbHMuIFRoaXMgdmFsdWUgc2hvdWxkIGJlIHVuaXF1ZVxuICAgKiBwZXIgcGFnZS5cbiAgICovXG4gIEBIb3N0QmluZGluZygnYXR0ci5kYXRhLWlkJylcbiAgQElucHV0KCkgaWRTdHJpbmc6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHZhbHVlIHN1cHBsaWVkIHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlXG4gICAqIGBkYXRhLWFuYWx5dGljc2AgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxuICAgKiBJbnRlbmRlZCBmb3IgYW4gb3V0c2lkZVxuICAgKiBsaWJyYXJ5IHRvIGNhcHR1cmUgZGF0YS5cbiAgICovXG4gIEBIb3N0QmluZGluZygnYXR0ci5kYXRhLWFuYWx5dGljcycpXG4gIEBJbnB1dCgpIGFuYWx5dGljc1N0cmluZzogc3RyaW5nO1xuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnZhcmlhbnQgPT09ICdzZWNvbmRhcnknKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKFxuICAgICAgICB0aGlzLnJlZi5uYXRpdmVFbGVtZW50LFxuICAgICAgICAnc3Byay1jLUJ1dHRvbi0tc2Vjb25kYXJ5J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmFyaWFudCA9PT0gJ3RlcnRpYXJ5Jykge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhcbiAgICAgICAgdGhpcy5yZWYubmF0aXZlRWxlbWVudCxcbiAgICAgICAgJ3NwcmstYy1CdXR0b24tLXRlcnRpYXJ5J1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIHNwaW5uZXIgb25seSBhZnRlciB2aWV3IGhhcyBsb2FkZWQuXG4gICAqIFRoaXMgaXMgdG8gYWxsb3cgdGltZSBmb3IgdGhlIHRleHRcbiAgICogY29udGVudCBvZiB0aGUgYnV0dG9uIHRvIGxvYWQgc28gdGhhdFxuICAgKiB0aGUgd2lkdGggdmFsdWUgYWNjb3VudHMgZm9yIHRoYXQgdGV4dC5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICBpZiAodGhpcy5pc1NwaW5uaW5nKSB7XG4gICAgICB0aGlzLnNldFNwaW5uaW5nKHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAodGhpcy5pc1NwaW5uaW5nICYmICFjaGFuZ2VzWydpc1NwaW5uaW5nJ10uaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICB0aGlzLnNldFNwaW5uaW5nKHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzZXRTcGlubmluZyA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgZWwgPSBlbGVtZW50O1xuICAgIGNvbnN0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICBjb25zdCBhcmlhTGFiZWwgPSB0aGlzLnNwaW5uaW5nQXJpYUxhYmVsO1xuICAgIGxldCBzcGlubmVyQ2xhc3MgPSAnc3Byay1jLVNwaW5uZXIgc3Byay1jLVNwaW5uZXItLWNpcmNsZSc7XG4gICAgaWYgKFxuICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3NwcmstYy1CdXR0b24tLXNlY29uZGFyeScpIHx8XG4gICAgICAgIHRoaXMudmFyaWFudCA9PT0gJ3NlY29uZGFyeScpIHtcbiAgICAgIHNwaW5uZXJDbGFzcyArPSAnIHNwcmstYy1TcGlubmVyLS1kYXJrJztcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoXG4gICAgICBlbCxcbiAgICAgICdkYXRhLXNwcmstc3Bpbm5lci10ZXh0JyxcbiAgICAgIGVsLnRleHRDb250ZW50LFxuICAgICk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoXG4gICAgICBlbCxcbiAgICAgICdhcmlhLWxhYmVsJyxcbiAgICAgIGFyaWFMYWJlbCxcbiAgICApO1xuICAgIGVsLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwiJHtzcGlubmVyQ2xhc3N9XCI+PC9kaXY+YDtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3Byay1oYXMtc3Bpbm5lcicsICd0cnVlJyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoXG4gICAgICBlbCxcbiAgICAgICdkYXRhLXNwcmstaGFzLXNwaW5uZXInLFxuICAgICAgJ3RydWUnLFxuICAgICk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoXG4gICAgICBlbCxcbiAgICAgICdzdHlsZScsXG4gICAgICBgd2lkdGg6ICR7d2lkdGh9cHhgLFxuICAgICk7XG4gIH1cbn1cbiJdfQ==