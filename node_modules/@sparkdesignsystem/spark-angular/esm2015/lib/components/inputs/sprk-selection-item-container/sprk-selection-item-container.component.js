import { __decorate, __metadata } from "tslib";
import { Component, ContentChild, Input, OnInit, Renderer2 } from '@angular/core';
import uniqueId from 'lodash/uniqueId';
import { SprkSelectionInputDirective } from '../../../directives/inputs/sprk-selection-input/sprk-selection-input.directive';
import { SprkSelectionLabelDirective } from '../../../directives/inputs/sprk-selection-label/sprk-selection-label.directive';
let SprkSelectionItemContainerComponent = class SprkSelectionItemContainerComponent {
    constructor(renderer) {
        this.renderer = renderer;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-SelectionContainer'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    addInputTypeClasses() {
        const inputType = this.input.ref.nativeElement.type;
        if (inputType === 'checkbox') {
            this.renderer.addClass(this.input.ref.nativeElement, 'sprk-b-Checkbox__input');
            this.renderer.addClass(this.label.ref.nativeElement, 'sprk-b-Checkbox__label');
        }
        if (inputType === 'radio') {
            this.renderer.addClass(this.input.ref.nativeElement, 'sprk-b-Radio__input');
            this.renderer.addClass(this.label.ref.nativeElement, 'sprk-b-Radio__label');
        }
    }
    /**
     * @ignore
     */
    generateIdForInput() {
        let inputId = this.input.ref.nativeElement.id;
        const labelFor = this.label.ref.nativeElement.htmlFor;
        // Warn if 'for' exists but the 'id' does not
        if (labelFor && !inputId) {
            console.warn(`Spark Design System Warning - The value of 'for' (${labelFor}) on the label expects a matching 'id' on the input.`);
            return;
        }
        // Warn if 'for' and 'id' both exist but don't match
        if (inputId && labelFor && inputId !== labelFor) {
            console.warn(`Spark Design System Warning - The value of 'for' (${labelFor}) on the label should match the 'id' on the input (${inputId}).`);
            return;
        }
        // If we don't have a valid id, generate one with lodash
        if (!inputId) {
            inputId = uniqueId(`sprk_input_`);
            this.renderer.setProperty(this.input.ref.nativeElement, 'id', inputId);
            this.renderer.setAttribute(this.label.ref.nativeElement, 'for', inputId);
        }
    }
    ngOnInit() {
        if (this.label && this.input) {
            this.generateIdForInput();
            this.addInputTypeClasses();
        }
    }
};
SprkSelectionItemContainerComponent.ctorParameters = () => [
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkSelectionItemContainerComponent.prototype, "additionalClasses", void 0);
__decorate([
    ContentChild(SprkSelectionLabelDirective, { static: true }),
    __metadata("design:type", SprkSelectionLabelDirective)
], SprkSelectionItemContainerComponent.prototype, "label", void 0);
__decorate([
    ContentChild(SprkSelectionInputDirective, { static: true }),
    __metadata("design:type", SprkSelectionInputDirective)
], SprkSelectionItemContainerComponent.prototype, "input", void 0);
SprkSelectionItemContainerComponent = __decorate([
    Component({
        selector: 'sprk-selection-item-container',
        template: `
    <div [ngClass]="getClasses()">
      <ng-content select="[sprkSelectionInput]"></ng-content>
      <ng-content select="[sprkSelectionLabel]"></ng-content>
      <ng-content></ng-content>
    </div>
  `
    }),
    __metadata("design:paramtypes", [Renderer2])
], SprkSelectionItemContainerComponent);
export { SprkSelectionItemContainerComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Byay1zZWxlY3Rpb24taXRlbS1jb250YWluZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJrZGVzaWduc3lzdGVtL3NwYXJrLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9pbnB1dHMvc3Byay1zZWxlY3Rpb24taXRlbS1jb250YWluZXIvc3Byay1zZWxlY3Rpb24taXRlbS1jb250YWluZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNsRixPQUFPLFFBQVEsTUFBTSxpQkFBaUIsQ0FBQztBQUN2QyxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxnRkFBZ0YsQ0FBQztBQUM3SCxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxnRkFBZ0YsQ0FBQztBQVk3SCxJQUFhLG1DQUFtQyxHQUFoRCxNQUFhLG1DQUFtQztJQUM5QyxZQUFxQixRQUFtQjtRQUFuQixhQUFRLEdBQVIsUUFBUSxDQUFXO0lBQUcsQ0FBQztJQXNCNUM7O09BRUc7SUFDSCxVQUFVO1FBQ1IsTUFBTSxVQUFVLEdBQWEsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1FBRTNELElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQzFCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNwRCxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzdCLENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsbUJBQW1CO1FBQ2pCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7UUFDcEQsSUFBSSxTQUFTLEtBQUssVUFBVSxFQUFFO1lBQzVCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO1lBQy9FLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO1NBQ2hGO1FBQ0QsSUFBSSxTQUFTLEtBQUssT0FBTyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO1lBQzVFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO1NBQzdFO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsa0JBQWtCO1FBQ2hCLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUM7UUFDOUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQztRQUV0RCw2Q0FBNkM7UUFDN0MsSUFBSSxRQUFRLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDeEIsT0FBTyxDQUFDLElBQUksQ0FBQyxxREFBcUQsUUFBUSxzREFBc0QsQ0FBQyxDQUFDO1lBQ2xJLE9BQU87U0FDUjtRQUVELG9EQUFvRDtRQUNwRCxJQUFJLE9BQU8sSUFBSSxRQUFRLElBQUksT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMvQyxPQUFPLENBQUMsSUFBSSxDQUNWLHFEQUFxRCxRQUFRLHNEQUFzRCxPQUFPLElBQUksQ0FDL0gsQ0FBQztZQUNGLE9BQU87U0FDUjtRQUVELHdEQUF3RDtRQUN4RCxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ1osT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNsQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ3ZFLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDMUU7SUFDSCxDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQzVCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1NBQzVCO0lBQ0gsQ0FBQztDQUNGLENBQUE7O1lBdkZnQyxTQUFTOztBQU94QztJQURDLEtBQUssRUFBRTs7OEVBQ2tCO0FBTzFCO0lBREMsWUFBWSxDQUFDLDJCQUEyQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDOzhCQUNyRCwyQkFBMkI7a0VBQUM7QUFNbkM7SUFEQyxZQUFZLENBQUMsMkJBQTJCLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUM7OEJBQ3JELDJCQUEyQjtrRUFBQztBQXJCeEIsbUNBQW1DO0lBVi9DLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSwrQkFBK0I7UUFDekMsUUFBUSxFQUFFOzs7Ozs7R0FNVDtLQUNGLENBQUM7cUNBRStCLFNBQVM7R0FEN0IsbUNBQW1DLENBd0YvQztTQXhGWSxtQ0FBbUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgSW5wdXQsIE9uSW5pdCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgdW5pcXVlSWQgZnJvbSAnbG9kYXNoL3VuaXF1ZUlkJztcbmltcG9ydCB7IFNwcmtTZWxlY3Rpb25JbnB1dERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvaW5wdXRzL3Nwcmstc2VsZWN0aW9uLWlucHV0L3Nwcmstc2VsZWN0aW9uLWlucHV0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTcHJrU2VsZWN0aW9uTGFiZWxEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi8uLi9kaXJlY3RpdmVzL2lucHV0cy9zcHJrLXNlbGVjdGlvbi1sYWJlbC9zcHJrLXNlbGVjdGlvbi1sYWJlbC5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdzcHJrLXNlbGVjdGlvbi1pdGVtLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBbbmdDbGFzc109XCJnZXRDbGFzc2VzKClcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltzcHJrU2VsZWN0aW9uSW5wdXRdXCI+PC9uZy1jb250ZW50PlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW3NwcmtTZWxlY3Rpb25MYWJlbF1cIj48L25nLWNvbnRlbnQ+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIGBcbn0pXG5leHBvcnQgY2xhc3MgU3Bya1NlbGVjdGlvbkl0ZW1Db250YWluZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICBjb25zdHJ1Y3RvciggcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuICAvKipcbiAgICogRXhwZWN0cyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmdcbiAgICogb2YgY2xhc3NlcyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICogY29tcG9uZW50LlxuICAgKi9cbiAgQElucHV0KClcbiAgYWRkaXRpb25hbENsYXNzZXM6IHN0cmluZztcblxuICAvKipcbiAgICogVGhpcyBjb21wb25lbnQgZXhwZWN0cyBhIGNoaWxkIGxhYmVsIGVsZW1lbnRcbiAgICogd2l0aCB0aGUgYHNwcmtTZWxlY3Rpb25MYWJlbGAgZGlyZWN0aXZlLlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChTcHJrU2VsZWN0aW9uTGFiZWxEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pXG4gIGxhYmVsOiBTcHJrU2VsZWN0aW9uTGFiZWxEaXJlY3RpdmU7XG4gIC8qKlxuICAgKiBUaGlzIGNvbXBvbmVudCBleHBlY3RzIGEgY2hpbGQgc2VsZWN0aW9uIGlucHV0XG4gICAqIHdpdGggdGhlIGBzcHJrU2VsZWN0aW9uSW5wdXRgIGRpcmVjdGl2ZS5cbiAgICovXG4gIEBDb250ZW50Q2hpbGQoU3Bya1NlbGVjdGlvbklucHV0RGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICBpbnB1dDogU3Bya1NlbGVjdGlvbklucHV0RGlyZWN0aXZlO1xuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBnZXRDbGFzc2VzKCk6IHN0cmluZyB7XG4gICAgY29uc3QgY2xhc3NBcnJheTogc3RyaW5nW10gPSBbJ3NwcmstYi1TZWxlY3Rpb25Db250YWluZXInXTtcblxuICAgIGlmICh0aGlzLmFkZGl0aW9uYWxDbGFzc2VzKSB7XG4gICAgICB0aGlzLmFkZGl0aW9uYWxDbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgICBjbGFzc0FycmF5LnB1c2goY2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjbGFzc0FycmF5LmpvaW4oJyAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhZGRJbnB1dFR5cGVDbGFzc2VzKCk6IHZvaWQge1xuICAgIGNvbnN0IGlucHV0VHlwZSA9IHRoaXMuaW5wdXQucmVmLm5hdGl2ZUVsZW1lbnQudHlwZTtcbiAgICBpZiAoaW5wdXRUeXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuaW5wdXQucmVmLm5hdGl2ZUVsZW1lbnQsICdzcHJrLWItQ2hlY2tib3hfX2lucHV0Jyk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMubGFiZWwucmVmLm5hdGl2ZUVsZW1lbnQsICdzcHJrLWItQ2hlY2tib3hfX2xhYmVsJyk7XG4gICAgfVxuICAgIGlmIChpbnB1dFR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5pbnB1dC5yZWYubmF0aXZlRWxlbWVudCwgJ3NwcmstYi1SYWRpb19faW5wdXQnKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5sYWJlbC5yZWYubmF0aXZlRWxlbWVudCwgJ3NwcmstYi1SYWRpb19fbGFiZWwnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZ2VuZXJhdGVJZEZvcklucHV0KCk6IHZvaWQge1xuICAgIGxldCBpbnB1dElkID0gdGhpcy5pbnB1dC5yZWYubmF0aXZlRWxlbWVudC5pZDtcbiAgICBjb25zdCBsYWJlbEZvciA9IHRoaXMubGFiZWwucmVmLm5hdGl2ZUVsZW1lbnQuaHRtbEZvcjtcblxuICAgIC8vIFdhcm4gaWYgJ2ZvcicgZXhpc3RzIGJ1dCB0aGUgJ2lkJyBkb2VzIG5vdFxuICAgIGlmIChsYWJlbEZvciAmJiAhaW5wdXRJZCkge1xuICAgICAgY29uc29sZS53YXJuKGBTcGFyayBEZXNpZ24gU3lzdGVtIFdhcm5pbmcgLSBUaGUgdmFsdWUgb2YgJ2ZvcicgKCR7bGFiZWxGb3J9KSBvbiB0aGUgbGFiZWwgZXhwZWN0cyBhIG1hdGNoaW5nICdpZCcgb24gdGhlIGlucHV0LmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdhcm4gaWYgJ2ZvcicgYW5kICdpZCcgYm90aCBleGlzdCBidXQgZG9uJ3QgbWF0Y2hcbiAgICBpZiAoaW5wdXRJZCAmJiBsYWJlbEZvciAmJiBpbnB1dElkICE9PSBsYWJlbEZvcikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgU3BhcmsgRGVzaWduIFN5c3RlbSBXYXJuaW5nIC0gVGhlIHZhbHVlIG9mICdmb3InICgke2xhYmVsRm9yfSkgb24gdGhlIGxhYmVsIHNob3VsZCBtYXRjaCB0aGUgJ2lkJyBvbiB0aGUgaW5wdXQgKCR7aW5wdXRJZH0pLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHZhbGlkIGlkLCBnZW5lcmF0ZSBvbmUgd2l0aCBsb2Rhc2hcbiAgICBpZiAoIWlucHV0SWQpIHtcbiAgICAgIGlucHV0SWQgPSB1bmlxdWVJZChgc3Bya19pbnB1dF9gKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbnB1dC5yZWYubmF0aXZlRWxlbWVudCwgJ2lkJywgaW5wdXRJZCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmxhYmVsLnJlZi5uYXRpdmVFbGVtZW50LCAnZm9yJywgaW5wdXRJZCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubGFiZWwgJiYgdGhpcy5pbnB1dCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlkRm9ySW5wdXQoKTtcbiAgICAgIHRoaXMuYWRkSW5wdXRUeXBlQ2xhc3NlcygpO1xuICAgIH1cbiAgfVxufVxuIl19