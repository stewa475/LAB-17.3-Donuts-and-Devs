import { __decorate, __metadata } from "tslib";
import { Directive, ElementRef, Input, OnInit } from '@angular/core';
import TinyDatePicker from 'tiny-date-picker';
let SprkDatepickerDirective = class SprkDatepickerDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    ngOnInit() {
        const input = this.ref.nativeElement;
        const tdpConfig = {
            mode: 'dp-below',
            lang: {
                days: ['S', 'M', 'T', 'W', 'T', 'F', 'S']
            },
            min: '01/1/2008',
            max: '01/1/2068',
            format: date => date
                .toLocaleDateString('en-US', {
                month: '2-digit',
                day: '2-digit',
                year: 'numeric'
            })
                .replace(/[^ -~]/g, '')
        };
        if (TinyDatePicker) {
            TinyDatePicker(input, Object.assign(Object.assign({}, tdpConfig), this.sprkDatePickerConfig)).on('select', () => {
                let event;
                if (typeof (Event) === 'function') {
                    event = new Event('input');
                }
                else {
                    event = document.createEvent('Event');
                    event.initEvent('input', true, true);
                }
                this.ref.nativeElement.dispatchEvent(event);
                this.ref.nativeElement.focus();
            });
        }
    }
};
SprkDatepickerDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkDatepickerDirective.prototype, "sprkDatePickerConfig", void 0);
SprkDatepickerDirective = __decorate([
    Directive({
        selector: '[sprkDatepicker]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkDatepickerDirective);
export { SprkDatepickerDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Byay1kYXRlcGlja2VyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFya2Rlc2lnbnN5c3RlbS9zcGFyay1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvaW5wdXRzL3NwcmstZGF0ZXBpY2tlci9zcHJrLWRhdGVwaWNrZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JFLE9BQU8sY0FBYyxNQUFNLGtCQUFrQixDQUFDO0FBSzlDLElBQWEsdUJBQXVCLEdBQXBDLE1BQWEsdUJBQXVCO0lBQ2xDOztPQUVHO0lBQ0gsWUFBbUIsR0FBZTtRQUFmLFFBQUcsR0FBSCxHQUFHLENBQVk7SUFBRyxDQUFDO0lBVXRDLFFBQVE7UUFDTixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQztRQUNyQyxNQUFNLFNBQVMsR0FBRztZQUNoQixJQUFJLEVBQUUsVUFBVTtZQUNoQixJQUFJLEVBQUU7Z0JBQ0osSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDO2FBQzFDO1lBQ0QsR0FBRyxFQUFFLFdBQVc7WUFDaEIsR0FBRyxFQUFFLFdBQVc7WUFDaEIsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQ2IsSUFBSTtpQkFDRCxrQkFBa0IsQ0FBQyxPQUFPLEVBQUU7Z0JBQzNCLEtBQUssRUFBRSxTQUFTO2dCQUNoQixHQUFHLEVBQUUsU0FBUztnQkFDZCxJQUFJLEVBQUUsU0FBUzthQUNoQixDQUFDO2lCQUNELE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDO1NBQzVCLENBQUM7UUFFRixJQUFJLGNBQWMsRUFBRTtZQUNsQixjQUFjLENBQUMsS0FBSyxrQ0FDZixTQUFTLEdBQ1QsSUFBSSxDQUFDLG9CQUFvQixFQUM1QixDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFO2dCQUVuQixJQUFJLEtBQUssQ0FBQztnQkFFVixJQUFJLE9BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxVQUFVLEVBQUU7b0JBQ2hDLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztpQkFDNUI7cUJBQU07b0JBQ0wsS0FBSyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3RDLEtBQUssQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDdEM7Z0JBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUM1QyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNqQyxDQUFDLENBQUMsQ0FBQztTQUNKO0lBQ0gsQ0FBQztDQUNGLENBQUE7O1lBakR5QixVQUFVOztBQVFsQztJQURDLEtBQUssRUFBRTs7cUVBQ3FCO0FBWmxCLHVCQUF1QjtJQUhuQyxTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsa0JBQWtCO0tBQzdCLENBQUM7cUNBS3dCLFVBQVU7R0FKdkIsdUJBQXVCLENBcURuQztTQXJEWSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBUaW55RGF0ZVBpY2tlciBmcm9tICd0aW55LWRhdGUtcGlja2VyJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3NwcmtEYXRlcGlja2VyXSdcbn0pXG5leHBvcnQgY2xhc3MgU3Bya0RhdGVwaWNrZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHJlZjogRWxlbWVudFJlZikge31cblxuICAvKipcbiAgICogRXhwb3NlcyBjb25maWd1cmF0aW9uIHByb3ZpZGVkXG4gICAqIGJ5IGB0aW55LWRhdGUtcGlja2VyYCxcbiAgICogc2VlIFtnaXRodWJdKGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc2Rhdmllcy90aW55LWRhdGUtcGlja2VyKSBmb3IgZG9jdW1lbnRhdGlvbi5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNwcmtEYXRlUGlja2VyQ29uZmlnOiBvYmplY3Q7XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLnJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IHRkcENvbmZpZyA9IHtcbiAgICAgIG1vZGU6ICdkcC1iZWxvdycsXG4gICAgICBsYW5nOiB7XG4gICAgICAgIGRheXM6IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddXG4gICAgICB9LFxuICAgICAgbWluOiAnMDEvMS8yMDA4JyxcbiAgICAgIG1heDogJzAxLzEvMjA2OCcsXG4gICAgICBmb3JtYXQ6IGRhdGUgPT5cbiAgICAgICAgZGF0ZVxuICAgICAgICAgIC50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywge1xuICAgICAgICAgICAgbW9udGg6ICcyLWRpZ2l0JyxcbiAgICAgICAgICAgIGRheTogJzItZGlnaXQnLFxuICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVwbGFjZSgvW14gLX5dL2csICcnKVxuICAgIH07XG5cbiAgICBpZiAoVGlueURhdGVQaWNrZXIpIHtcbiAgICAgIFRpbnlEYXRlUGlja2VyKGlucHV0LCB7XG4gICAgICAgIC4uLnRkcENvbmZpZyxcbiAgICAgICAgLi4udGhpcy5zcHJrRGF0ZVBpY2tlckNvbmZpZ1xuICAgICAgfSkub24oJ3NlbGVjdCcsICgpID0+IHtcblxuICAgICAgICBsZXQgZXZlbnQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZihFdmVudCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBldmVudCA9IG5ldyBFdmVudCgnaW5wdXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnaW5wdXQnLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIl19