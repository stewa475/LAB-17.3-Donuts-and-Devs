import { __decorate, __metadata } from "tslib";
import { Directive, ElementRef, Input, OnInit } from '@angular/core';
let SprkTabbedNavigationTabDirective = class SprkTabbedNavigationTabDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Tabs__button'];
        if (this.defaultActive) {
            classArray.push('sprk-c-Tabs__button--active');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(item => {
            this.ref.nativeElement.classList.add(item);
        });
        this.ref.nativeElement.setAttribute('role', 'tab');
        this.ref.nativeElement.setAttribute('aria-selected', this.defaultActive ? 'true' : 'false');
        if (this.analyticsString) {
            this.ref.nativeElement.setAttribute('data-analytics', this.analyticsString);
        }
    }
};
SprkTabbedNavigationTabDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTabbedNavigationTabDirective.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkTabbedNavigationTabDirective.prototype, "defaultActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTabbedNavigationTabDirective.prototype, "analyticsString", void 0);
SprkTabbedNavigationTabDirective = __decorate([
    Directive({
        selector: '[sprkTabbedNavigationTab]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkTabbedNavigationTabDirective);
export { SprkTabbedNavigationTabDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Byay10YWJiZWQtbmF2aWdhdGlvbi10YWIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJrZGVzaWduc3lzdGVtL3NwYXJrLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy90YWJiZWQtbmF2aWdhdGlvbi9zcHJrLXRhYmJlZC1uYXZpZ2F0aW9uLXRhYi9zcHJrLXRhYmJlZC1uYXZpZ2F0aW9uLXRhYi5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFLckUsSUFBYSxnQ0FBZ0MsR0FBN0MsTUFBYSxnQ0FBZ0M7SUE0RDNDOztPQUVHO0lBQ0gsWUFBbUIsR0FBZTtRQUFmLFFBQUcsR0FBSCxHQUFHLENBQVk7SUFBRyxDQUFDO0lBeEN0Qzs7T0FFRztJQUNILFVBQVU7UUFDUixNQUFNLFVBQVUsR0FBYSxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFFckQsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3RCLFVBQVUsQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUNoRDtRQUVELElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQzFCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNwRCxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzdCLENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbkQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUNqQyxlQUFlLEVBQ2YsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQ3RDLENBQUM7UUFFRixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUNqQyxnQkFBZ0IsRUFDaEIsSUFBSSxDQUFDLGVBQWUsQ0FDckIsQ0FBQztTQUNIO0lBQ0gsQ0FBQztDQUtGLENBQUE7O1lBRHlCLFVBQVU7O0FBeERsQztJQURDLEtBQUssRUFBRTs7MkVBQ2tCO0FBTTFCO0lBREMsS0FBSyxFQUFFOzt1RUFDZTtBQVF2QjtJQURDLEtBQUssRUFBRTs7eUVBQ2dCO0FBckJiLGdDQUFnQztJQUg1QyxTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsMkJBQTJCO0tBQ3RDLENBQUM7cUNBZ0V3QixVQUFVO0dBL0R2QixnQ0FBZ0MsQ0FnRTVDO1NBaEVZLGdDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbc3Bya1RhYmJlZE5hdmlnYXRpb25UYWJdJ1xufSlcbmV4cG9ydCBjbGFzcyBTcHJrVGFiYmVkTmF2aWdhdGlvblRhYkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gLyoqXG4gICogRXhwZWN0cyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmdcbiAgKiBvZiBjbGFzc2VzIHRvIGJlIGFkZGVkIHRvIHRoZVxuICAqIGVsZW1lbnQuXG4gICovXG4gIEBJbnB1dCgpXG4gIGFkZGl0aW9uYWxDbGFzc2VzOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBUYWIgd2lsbCBoYXZlXG4gICAqIGFjdGl2ZSBzdHlsZXMgYW5kIGFyaWEgYXR0cmlidXRlcyBvbiByZW5kZXIuXG4gICAqL1xuICBASW5wdXQoKVxuICBkZWZhdWx0QWN0aXZlOiBib29sZWFuO1xuICAvKipcbiAgICogVGhlIHZhbHVlIHN1cHBsaWVkIHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlXG4gICAqIGBkYXRhLWFuYWx5dGljc2AgYXR0cmlidXRlIG9uIHRoZSBjb21wb25lbnQuXG4gICAqIEludGVuZGVkIGZvciBhbiBvdXRzaWRlXG4gICAqIGxpYnJhcnkgdG8gY2FwdHVyZSBkYXRhLlxuICAgKi9cbiAgQElucHV0KClcbiAgYW5hbHl0aWNzU3RyaW5nOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGdldENsYXNzZXMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGNsYXNzQXJyYXk6IHN0cmluZ1tdID0gWydzcHJrLWMtVGFic19fYnV0dG9uJ107XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0QWN0aXZlKSB7XG4gICAgICBjbGFzc0FycmF5LnB1c2goJ3NwcmstYy1UYWJzX19idXR0b24tLWFjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkZGl0aW9uYWxDbGFzc2VzKSB7XG4gICAgICB0aGlzLmFkZGl0aW9uYWxDbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgICBjbGFzc0FycmF5LnB1c2goY2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjbGFzc0FycmF5O1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5nZXRDbGFzc2VzKCkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChpdGVtKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RhYicpO1xuICAgIHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgJ2FyaWEtc2VsZWN0ZWQnLFxuICAgICAgdGhpcy5kZWZhdWx0QWN0aXZlID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgICk7XG5cbiAgICBpZiAodGhpcy5hbmFseXRpY3NTdHJpbmcpIHtcbiAgICAgIHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgICAnZGF0YS1hbmFseXRpY3MnLFxuICAgICAgICB0aGlzLmFuYWx5dGljc1N0cmluZ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWY6IEVsZW1lbnRSZWYpIHt9XG59XG4iXX0=