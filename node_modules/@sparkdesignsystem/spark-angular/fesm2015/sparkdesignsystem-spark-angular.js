import { __decorate, __metadata } from 'tslib';
import { ElementRef, HostListener, Directive, NgModule, Input, ContentChild, Component, Renderer2, ContentChildren, QueryList, HostBinding, EventEmitter, Output, ViewChild, TemplateRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule, Router, NavigationEnd } from '@angular/router';
import TinyDatePicker from 'tiny-date-picker';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { uniqueId, throttle } from 'lodash';
import uniqueId$1 from 'lodash/uniqueId';
import { trigger, state, style, transition, animate } from '@angular/animations';
import 'focus-visible';

const environment = {
    version: '10.0.0'
};

let SprkFormatterDateDirective = class SprkFormatterDateDirective {
    constructor(ref) {
        this.ref = ref;
    }
    onFocus(value) {
        this.ref.nativeElement.value = this.formatDate(value);
    }
    formatDate(value) {
        const m = value.match(
        // tslint:disable-next-line:max-line-length
        /^(((0[13578]|1[02])([/-]?)(0[1-9]|[12]\d|3[01])|(0[469]|11)([/-]?)(0[1-9]|[12]\d|30)|02([/-]?)((0[1-9])|[12]\d))(\4|\7|\9)[12]\d{3})?$/);
        let newValue = '';
        const cleanValue = value.replace(/[/-]/g, '');
        if (m) {
            for (let i = 0; i < cleanValue.length; i += 1) {
                if (i === 1 || i === 3) {
                    newValue += `${cleanValue[i]}/`;
                }
                else {
                    newValue += cleanValue[i];
                }
            }
            return newValue;
        }
        else {
            return value;
        }
    }
};
SprkFormatterDateDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostListener('input', ['$event.target.value']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkFormatterDateDirective.prototype, "onFocus", null);
SprkFormatterDateDirective = __decorate([
    Directive({
        selector: '[sprkFormatterDate]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkFormatterDateDirective);

let SprkFormatterDateModule = class SprkFormatterDateModule {
};
SprkFormatterDateModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkFormatterDateDirective],
        exports: [SprkFormatterDateDirective]
    })
], SprkFormatterDateModule);

let SprkFormatterMonetaryDirective = class SprkFormatterMonetaryDirective {
    constructor(ref) {
        this.ref = ref;
    }
    onBlur(value) {
        this.ref.nativeElement.value = this.formatMonetary(value);
    }
    formatMonetary(value) {
        let number;
        if (this.ref.nativeElement.validity.valid) {
            number = Number(value.replace(/[\$,]/g, ''));
            if (isNaN(number)) {
                return value;
            }
            return number
                .toLocaleString('en-US', { style: 'currency', currency: 'USD' })
                .replace(/\$/g, '');
        }
        return value;
    }
};
SprkFormatterMonetaryDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostListener('blur', ['this.ref.nativeElement.value']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkFormatterMonetaryDirective.prototype, "onBlur", null);
SprkFormatterMonetaryDirective = __decorate([
    Directive({
        selector: '[sprkFormatterMonetary]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkFormatterMonetaryDirective);

let SprkFormatterMonetaryModule = class SprkFormatterMonetaryModule {
};
SprkFormatterMonetaryModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkFormatterMonetaryDirective],
        exports: [SprkFormatterMonetaryDirective]
    })
], SprkFormatterMonetaryModule);

let SprkFormatterPhoneNumberDirective = class SprkFormatterPhoneNumberDirective {
    constructor(ref) {
        this.ref = ref;
    }
    onFocus(value) {
        this.ref.nativeElement.value = this.formatPhone(value);
    }
    formatPhone(value) {
        const newValue = `${value}`.replace(/\D/g, '');
        const m = newValue.match(/^(\d{3})(\d{3})(\d{4})$/);
        if (m) {
            return `(${m[1]}) ${m[2]}-${m[3]}`;
        }
        else {
            return value;
        }
    }
};
SprkFormatterPhoneNumberDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostListener('input', ['$event.target.value']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkFormatterPhoneNumberDirective.prototype, "onFocus", null);
SprkFormatterPhoneNumberDirective = __decorate([
    Directive({
        selector: '[sprkFormatterPhoneNumber]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkFormatterPhoneNumberDirective);

let SprkFormatterPhoneNumberModule = class SprkFormatterPhoneNumberModule {
};
SprkFormatterPhoneNumberModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkFormatterPhoneNumberDirective],
        exports: [SprkFormatterPhoneNumberDirective]
    })
], SprkFormatterPhoneNumberModule);

let SprkFormatterSsnDirective = class SprkFormatterSsnDirective {
    constructor(ref) {
        this.ref = ref;
    }
    onFocus(value) {
        this.ref.nativeElement.value = this.formatSSN(value);
    }
    formatSSN(value) {
        const m = value.match(/(^(?!666|000|9\d{2})\d{3}([-]{0,1})(?!00)\d{2}\1(?!0{4})\2\d{4}$)|^$/);
        if (m) {
            let val = value.trim().replace(/[ -]/g, '');
            let newVal = '';
            const sizes = [3, 2, 4];
            sizes.forEach(size => {
                if (val.length > size) {
                    newVal += `${val.substr(0, size)}-`;
                    val = val.substr(size);
                }
            });
            newVal += val;
            return newVal;
        }
        return value;
    }
};
SprkFormatterSsnDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostListener('input', ['$event.target.value']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkFormatterSsnDirective.prototype, "onFocus", null);
SprkFormatterSsnDirective = __decorate([
    Directive({
        selector: '[sprkFormatterSsn]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkFormatterSsnDirective);

let SprkFormatterSsnModule = class SprkFormatterSsnModule {
};
SprkFormatterSsnModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkFormatterSsnDirective],
        exports: [SprkFormatterSsnDirective]
    })
], SprkFormatterSsnModule);

let SprkDatepickerDirective = class SprkDatepickerDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    ngOnInit() {
        const input = this.ref.nativeElement;
        const tdpConfig = {
            mode: 'dp-below',
            lang: {
                days: ['S', 'M', 'T', 'W', 'T', 'F', 'S']
            },
            min: '01/1/2008',
            max: '01/1/2068',
            format: date => date
                .toLocaleDateString('en-US', {
                month: '2-digit',
                day: '2-digit',
                year: 'numeric'
            })
                .replace(/[^ -~]/g, '')
        };
        if (TinyDatePicker) {
            TinyDatePicker(input, Object.assign(Object.assign({}, tdpConfig), this.sprkDatePickerConfig)).on('select', () => {
                let event;
                if (typeof (Event) === 'function') {
                    event = new Event('input');
                }
                else {
                    event = document.createEvent('Event');
                    event.initEvent('input', true, true);
                }
                this.ref.nativeElement.dispatchEvent(event);
                this.ref.nativeElement.focus();
            });
        }
    }
};
SprkDatepickerDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkDatepickerDirective.prototype, "sprkDatePickerConfig", void 0);
SprkDatepickerDirective = __decorate([
    Directive({
        selector: '[sprkDatepicker]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkDatepickerDirective);

let SprkDatepickerModule = class SprkDatepickerModule {
};
SprkDatepickerModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkDatepickerDirective],
        exports: [SprkDatepickerDirective]
    })
], SprkDatepickerModule);

let SprkFieldErrorDirective = class SprkFieldErrorDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-ErrorContainer'];
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(item => {
            this.ref.nativeElement.classList.add(item);
        });
    }
};
SprkFieldErrorDirective.ctorParameters = () => [
    { type: ElementRef }
];
SprkFieldErrorDirective = __decorate([
    Directive({
        selector: '[sprkFieldError]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkFieldErrorDirective);

let SprkFieldErrorModule = class SprkFieldErrorModule {
};
SprkFieldErrorModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkFieldErrorDirective],
        exports: [SprkFieldErrorDirective]
    })
], SprkFieldErrorModule);

let SprkHelperTextDirective = class SprkHelperTextDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-HelperText'];
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(item => {
            this.ref.nativeElement.classList.add(item);
        });
    }
};
SprkHelperTextDirective.ctorParameters = () => [
    { type: ElementRef }
];
SprkHelperTextDirective = __decorate([
    Directive({
        selector: '[sprkHelperText]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkHelperTextDirective);

let SprkHelperTextModule = class SprkHelperTextModule {
};
SprkHelperTextModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkHelperTextDirective],
        exports: [SprkHelperTextDirective]
    })
], SprkHelperTextModule);

let SprkInputDirective = class SprkInputDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    OnChange($event) {
        const value = this.ref.nativeElement.value;
        if (value.length > 0) {
            this.ref.nativeElement.classList.add('sprk-b-Input--has-floating-label');
        }
        else {
            this.ref.nativeElement.classList.remove('sprk-b-Input--has-floating-label');
        }
    }
    ngOnInit() {
        if (this.ref.nativeElement.nodeName === 'SELECT') {
            this.ref.nativeElement.classList.add('sprk-b-Select');
        }
        else if (this.ref.nativeElement.nodeName === 'TEXTAREA') {
            this.ref.nativeElement.classList.add('sprk-b-TextInput');
            this.ref.nativeElement.classList.add('sprk-b-TextArea');
        }
        else {
            this.ref.nativeElement.classList.add('sprk-b-TextInput');
        }
        if (this.ref.nativeElement.value.length > 0) {
            this.ref.nativeElement.classList.add('sprk-b-Input--has-floating-label');
        }
        this.ref.nativeElement.classList.add('sprk-u-Width-100');
    }
};
SprkInputDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostListener('change', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkInputDirective.prototype, "OnChange", null);
SprkInputDirective = __decorate([
    Directive({
        selector: '[sprkInput]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkInputDirective);

let SprkInputModule = class SprkInputModule {
};
SprkInputModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkInputDirective],
        exports: [SprkInputDirective]
    })
], SprkInputModule);

let SprkLabelDirective = class SprkLabelDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-Label'];
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(item => {
            this.ref.nativeElement.classList.add(item);
        });
    }
};
SprkLabelDirective.ctorParameters = () => [
    { type: ElementRef }
];
SprkLabelDirective = __decorate([
    Directive({
        selector: '[sprkLabel]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkLabelDirective);

let SprkLabelModule = class SprkLabelModule {
};
SprkLabelModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkLabelDirective],
        exports: [SprkLabelDirective]
    })
], SprkLabelModule);

let SprkSelectionInputDirective = class SprkSelectionInputDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-SelectionInput'];
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(item => {
            this.ref.nativeElement.classList.add(item);
        });
    }
};
SprkSelectionInputDirective.ctorParameters = () => [
    { type: ElementRef }
];
SprkSelectionInputDirective = __decorate([
    Directive({
        selector: '[sprkSelectionInput]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkSelectionInputDirective);

let SprkSelectionInputModule = class SprkSelectionInputModule {
};
SprkSelectionInputModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkSelectionInputDirective],
        exports: [SprkSelectionInputDirective]
    })
], SprkSelectionInputModule);

let SprkSelectionLabelDirective = class SprkSelectionLabelDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-Label', 'sprk-b-Label--inline'];
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(item => {
            this.ref.nativeElement.classList.add(item);
        });
    }
};
SprkSelectionLabelDirective.ctorParameters = () => [
    { type: ElementRef }
];
SprkSelectionLabelDirective = __decorate([
    Directive({
        selector: '[sprkSelectionLabel]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkSelectionLabelDirective);

let SprkSelectionLabelModule = class SprkSelectionLabelModule {
};
SprkSelectionLabelModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkSelectionLabelDirective],
        exports: [SprkSelectionLabelDirective]
    })
], SprkSelectionLabelModule);

let SprkStackItemDirective = class SprkStackItemDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    ngOnInit() {
        this.ref.nativeElement.classList.add('sprk-o-Stack__item');
    }
};
SprkStackItemDirective.ctorParameters = () => [
    { type: ElementRef }
];
SprkStackItemDirective = __decorate([
    Directive({
        selector: '[sprkStackItem]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkStackItemDirective);

let SprkStackItemModule = class SprkStackItemModule {
};
SprkStackItemModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkStackItemDirective],
        exports: [SprkStackItemDirective]
    })
], SprkStackItemModule);

let SprkTableEmptyHeadingDirective = class SprkTableEmptyHeadingDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-Table__empty-heading'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(className => {
            this.ref.nativeElement.classList.add(className);
        });
    }
};
SprkTableEmptyHeadingDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTableEmptyHeadingDirective.prototype, "additionalClasses", void 0);
SprkTableEmptyHeadingDirective = __decorate([
    Directive({
        selector: '[sprkTableEmptyHeading]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkTableEmptyHeadingDirective);

let SprkTableEmptyHeadingModule = class SprkTableEmptyHeadingModule {
};
SprkTableEmptyHeadingModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkTableEmptyHeadingDirective],
        exports: [SprkTableEmptyHeadingDirective]
    })
], SprkTableEmptyHeadingModule);

let SprkTableGroupedColumnDirective = class SprkTableGroupedColumnDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-Table__grouped-column'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(className => {
            this.ref.nativeElement.classList.add(className);
        });
    }
};
SprkTableGroupedColumnDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTableGroupedColumnDirective.prototype, "additionalClasses", void 0);
SprkTableGroupedColumnDirective = __decorate([
    Directive({
        selector: '[sprkTableGroupedColumn]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkTableGroupedColumnDirective);

let SprkTableGroupedColumnModule = class SprkTableGroupedColumnModule {
};
SprkTableGroupedColumnModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkTableGroupedColumnDirective],
        exports: [SprkTableGroupedColumnDirective]
    })
], SprkTableGroupedColumnModule);

let SprkTableHeadDirective = class SprkTableHeadDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-Table__head'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(className => {
            this.ref.nativeElement.classList.add(className);
        });
    }
};
SprkTableHeadDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTableHeadDirective.prototype, "additionalClasses", void 0);
SprkTableHeadDirective = __decorate([
    Directive({
        selector: '[sprkTableHead]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkTableHeadDirective);

let SprkTableHeadModule = class SprkTableHeadModule {
};
SprkTableHeadModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkTableHeadDirective],
        exports: [SprkTableHeadDirective]
    })
], SprkTableHeadModule);

let SprkTableRowHeadingDirective = class SprkTableRowHeadingDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-Table__row-heading'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(className => {
            this.ref.nativeElement.classList.add(className);
        });
    }
};
SprkTableRowHeadingDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTableRowHeadingDirective.prototype, "additionalClasses", void 0);
SprkTableRowHeadingDirective = __decorate([
    Directive({
        selector: '[sprkTableRowHeading]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkTableRowHeadingDirective);

let SprkTableRowHeadingModule = class SprkTableRowHeadingModule {
};
SprkTableRowHeadingModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkTableRowHeadingDirective],
        exports: [SprkTableRowHeadingDirective]
    })
], SprkTableRowHeadingModule);

let SprkTabbedNavigationPanelDirective = class SprkTabbedNavigationPanelDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Tabs__content'];
        if (!this.defaultActive) {
            classArray.push('sprk-u-HideWhenJs');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray;
    }
    ngOnInit() {
        this.ref.nativeElement.setAttribute('role', 'tabpanel');
        this.ref.nativeElement.setAttribute('tabindex', '0');
        this.getClasses().forEach(item => {
            this.ref.nativeElement.classList.add(item);
        });
    }
};
SprkTabbedNavigationPanelDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTabbedNavigationPanelDirective.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkTabbedNavigationPanelDirective.prototype, "defaultActive", void 0);
SprkTabbedNavigationPanelDirective = __decorate([
    Directive({
        selector: '[sprkTabbedNavigationPanel]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkTabbedNavigationPanelDirective);

let SprkTabbedNavigationPanelModule = class SprkTabbedNavigationPanelModule {
};
SprkTabbedNavigationPanelModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkTabbedNavigationPanelDirective],
        exports: [SprkTabbedNavigationPanelDirective]
    })
], SprkTabbedNavigationPanelModule);

let SprkTabbedNavigationTabDirective = class SprkTabbedNavigationTabDirective {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Tabs__button'];
        if (this.defaultActive) {
            classArray.push('sprk-c-Tabs__button--active');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray;
    }
    ngOnInit() {
        this.getClasses().forEach(item => {
            this.ref.nativeElement.classList.add(item);
        });
        this.ref.nativeElement.setAttribute('role', 'tab');
        this.ref.nativeElement.setAttribute('aria-selected', this.defaultActive ? 'true' : 'false');
        if (this.analyticsString) {
            this.ref.nativeElement.setAttribute('data-analytics', this.analyticsString);
        }
    }
};
SprkTabbedNavigationTabDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTabbedNavigationTabDirective.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkTabbedNavigationTabDirective.prototype, "defaultActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTabbedNavigationTabDirective.prototype, "analyticsString", void 0);
SprkTabbedNavigationTabDirective = __decorate([
    Directive({
        selector: '[sprkTabbedNavigationTab]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkTabbedNavigationTabDirective);

let SprkTabbedNavigationTabModule = class SprkTabbedNavigationTabModule {
};
SprkTabbedNavigationTabModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkTabbedNavigationTabDirective],
        exports: [SprkTabbedNavigationTabDirective]
    })
], SprkTabbedNavigationTabModule);

let SparkInputContainerComponent = class SparkInputContainerComponent {
    constructor() {
        /**
         * @ignore
         */
        this.id = uniqueId();
        /**
         * @ignore
         */
        this.input_id = `input_${this.id}`;
        /**
         * @ignore
         */
        this.error_id = `error_${this.id}`;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-InputContainer'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    ngOnInit() {
        if (this.label && this.input) {
            this.label.ref.nativeElement.setAttribute('for', this.input_id);
            this.input.ref.nativeElement.id = this.input_id;
        }
        if (this.input && this.error) {
            this.input.ref.nativeElement.setAttribute('aria-describedby', this.error_id);
            this.error.ref.nativeElement.id = this.error_id;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SparkInputContainerComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SparkInputContainerComponent.prototype, "iconContainerClasses", void 0);
__decorate([
    ContentChild(SprkLabelDirective, { static: true }),
    __metadata("design:type", SprkLabelDirective)
], SparkInputContainerComponent.prototype, "label", void 0);
__decorate([
    ContentChild(SprkInputDirective, { static: true }),
    __metadata("design:type", SprkInputDirective)
], SparkInputContainerComponent.prototype, "input", void 0);
__decorate([
    ContentChild(SprkFieldErrorDirective, { static: true }),
    __metadata("design:type", SprkFieldErrorDirective)
], SparkInputContainerComponent.prototype, "error", void 0);
SparkInputContainerComponent = __decorate([
    Component({
        selector: 'sprk-input-container',
        template: `
    <div [ngClass]="getClasses()">
      <ng-content select="[sprkLabel]"></ng-content>
      <ng-content select="[sprkInput]"></ng-content>
      <ng-content select="[sprk-select-icon]"></ng-content>
      <ng-content select="sprk-selection-item-container"></ng-content>
      <ng-content select="[sprkHelperText]"></ng-content>
      <ng-content select="[sprkFieldError]"></ng-content>
    </div>
  `
    })
], SparkInputContainerComponent);

let SparkInputContainerModule = class SparkInputContainerModule {
};
SparkInputContainerModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, FormsModule, ReactiveFormsModule],
        declarations: [SparkInputContainerComponent],
        exports: [SparkInputContainerComponent]
    })
], SparkInputContainerModule);

let SprkHugeInputContainerComponent = class SprkHugeInputContainerComponent {
    constructor() {
        /**
         * @ignore
         */
        this.id = uniqueId();
        /**
         * @ignore
         */
        this.input_id = `input_${this.id}`;
        /**
         * @ignore
         */
        this.error_id = `error_${this.id}`;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-b-InputContainer',
            'sprk-b-InputContainer--huge'
        ];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    ngOnInit() {
        if (this.label && this.input) {
            this.label.ref.nativeElement.setAttribute('for', this.input_id);
            this.input.ref.nativeElement.id = this.input_id;
        }
        if (this.input && this.error) {
            this.input.ref.nativeElement.setAttribute('aria-describedby', this.error_id);
            this.error.ref.nativeElement.id = this.error_id;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHugeInputContainerComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHugeInputContainerComponent.prototype, "iconContainerClasses", void 0);
__decorate([
    ContentChild(SprkLabelDirective, { static: true }),
    __metadata("design:type", SprkLabelDirective)
], SprkHugeInputContainerComponent.prototype, "label", void 0);
__decorate([
    ContentChild(SprkInputDirective, { static: true }),
    __metadata("design:type", SprkInputDirective)
], SprkHugeInputContainerComponent.prototype, "input", void 0);
__decorate([
    ContentChild(SprkFieldErrorDirective, { static: true }),
    __metadata("design:type", SprkFieldErrorDirective)
], SprkHugeInputContainerComponent.prototype, "error", void 0);
SprkHugeInputContainerComponent = __decorate([
    Component({
        selector: 'sprk-huge-input-container',
        template: `
    <div [ngClass]="getClasses()">
      <ng-content select="[sprkInput]"></ng-content>
      <ng-content select="[sprkLabel]"></ng-content>
      <ng-content select="[sprk-select-icon]"></ng-content>
      <ng-content select="sprk-selection-item-container"></ng-content>
      <ng-content select="[sprkHelperText]"></ng-content>
      <ng-content select="[sprkFieldError]"></ng-content>
    </div>
  `
    })
], SprkHugeInputContainerComponent);

let SprkHugeInputContainerModule = class SprkHugeInputContainerModule {
};
SprkHugeInputContainerModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, FormsModule, ReactiveFormsModule],
        declarations: [SprkHugeInputContainerComponent],
        exports: [SprkHugeInputContainerComponent]
    })
], SprkHugeInputContainerModule);

let SprkTextareaContainerComponent = class SprkTextareaContainerComponent {
    constructor() {
        /**
         * @ignore
         */
        this.id = uniqueId();
        /**
         * @ignore
         */
        this.input_id = `input_${this.id}`;
        /**
         * @ignore
         */
        this.error_id = `error_${this.id}`;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-b-InputContainer',
            'sprk-b-InputContainer--textarea'
        ];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    ngOnInit() {
        if (this.label && this.input) {
            this.label.ref.nativeElement.setAttribute('for', this.input_id);
            this.input.ref.nativeElement.id = this.input_id;
        }
        if (this.input && this.error) {
            this.input.ref.nativeElement.setAttribute('aria-describedby', this.error_id);
            this.error.ref.nativeElement.id = this.error_id;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTextareaContainerComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTextareaContainerComponent.prototype, "iconContainerClasses", void 0);
__decorate([
    ContentChild(SprkLabelDirective, { static: true }),
    __metadata("design:type", SprkLabelDirective)
], SprkTextareaContainerComponent.prototype, "label", void 0);
__decorate([
    ContentChild(SprkInputDirective, { static: true }),
    __metadata("design:type", SprkInputDirective)
], SprkTextareaContainerComponent.prototype, "input", void 0);
__decorate([
    ContentChild(SprkFieldErrorDirective, { static: true }),
    __metadata("design:type", SprkFieldErrorDirective)
], SprkTextareaContainerComponent.prototype, "error", void 0);
SprkTextareaContainerComponent = __decorate([
    Component({
        selector: 'sprk-textarea-container',
        template: `
    <div [ngClass]="getClasses()">
      <ng-content select="[sprkLabel]"></ng-content>
      <ng-content select="[sprkInput]"></ng-content>
      <ng-content select="sprk-selection-item-container"></ng-content>
      <ng-content select="[sprkHelperText]"></ng-content>
      <ng-content select="[sprkFieldError]"></ng-content>
    </div>
  `
    })
], SprkTextareaContainerComponent);

let SprkTextareaContainerModule = class SprkTextareaContainerModule {
};
SprkTextareaContainerModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, FormsModule, ReactiveFormsModule],
        declarations: [SprkTextareaContainerComponent],
        exports: [SprkTextareaContainerComponent]
    })
], SprkTextareaContainerModule);

let SprkIconInputContainerComponent = class SprkIconInputContainerComponent {
    constructor() {
        /**
         * @ignore
         */
        this.id = uniqueId();
        /**
         * @ignore
         */
        this.input_id = `input_${this.id}`;
        /**
         * @ignore
         */
        this.error_id = `error_${this.id}`;
    }
    /**
     * @ignore
     */
    getIconContainerClasses() {
        const classArray = ['sprk-b-InputContainer__icon-container'];
        if (this.iconContainerClasses) {
            this.iconContainerClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-InputContainer'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    ngOnInit() {
        if (this.label && this.input) {
            this.label.ref.nativeElement.setAttribute('for', this.input_id);
            this.input.ref.nativeElement.id = this.input_id;
        }
        if (this.input && this.error) {
            this.input.ref.nativeElement.setAttribute('aria-describedby', this.error_id);
            this.error.ref.nativeElement.id = this.error_id;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkIconInputContainerComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkIconInputContainerComponent.prototype, "iconContainerClasses", void 0);
__decorate([
    ContentChild(SprkLabelDirective, { static: true }),
    __metadata("design:type", SprkLabelDirective)
], SprkIconInputContainerComponent.prototype, "label", void 0);
__decorate([
    ContentChild(SprkInputDirective, { static: true }),
    __metadata("design:type", SprkInputDirective)
], SprkIconInputContainerComponent.prototype, "input", void 0);
__decorate([
    ContentChild(SprkFieldErrorDirective, { static: true }),
    __metadata("design:type", SprkFieldErrorDirective)
], SprkIconInputContainerComponent.prototype, "error", void 0);
SprkIconInputContainerComponent = __decorate([
    Component({
        selector: 'sprk-icon-input-container',
        template: `
    <div [ngClass]="getClasses()">
      <div [ngClass]="getIconContainerClasses()">
        <ng-content select="[sprkLabel]"></ng-content>
        <ng-content select="[sprk-input-icon]"></ng-content>
        <ng-content select="[sprkInput]"></ng-content>
      </div>
      <ng-content select="sprk-selection-item-container"></ng-content>
      <ng-content select="[sprkHelperText]"></ng-content>
      <ng-content select="[sprkFieldError]"></ng-content>
    </div>
  `
    })
], SprkIconInputContainerComponent);

let SprkIconInputContainerModule = class SprkIconInputContainerModule {
};
SprkIconInputContainerModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, FormsModule, ReactiveFormsModule],
        declarations: [SprkIconInputContainerComponent],
        exports: [SprkIconInputContainerComponent]
    })
], SprkIconInputContainerModule);

let SprkSelectionItemContainerComponent = class SprkSelectionItemContainerComponent {
    constructor(renderer) {
        this.renderer = renderer;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-SelectionContainer'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    addInputTypeClasses() {
        const inputType = this.input.ref.nativeElement.type;
        if (inputType === 'checkbox') {
            this.renderer.addClass(this.input.ref.nativeElement, 'sprk-b-Checkbox__input');
            this.renderer.addClass(this.label.ref.nativeElement, 'sprk-b-Checkbox__label');
        }
        if (inputType === 'radio') {
            this.renderer.addClass(this.input.ref.nativeElement, 'sprk-b-Radio__input');
            this.renderer.addClass(this.label.ref.nativeElement, 'sprk-b-Radio__label');
        }
    }
    /**
     * @ignore
     */
    generateIdForInput() {
        let inputId = this.input.ref.nativeElement.id;
        const labelFor = this.label.ref.nativeElement.htmlFor;
        // Warn if 'for' exists but the 'id' does not
        if (labelFor && !inputId) {
            console.warn(`Spark Design System Warning - The value of 'for' (${labelFor}) on the label expects a matching 'id' on the input.`);
            return;
        }
        // Warn if 'for' and 'id' both exist but don't match
        if (inputId && labelFor && inputId !== labelFor) {
            console.warn(`Spark Design System Warning - The value of 'for' (${labelFor}) on the label should match the 'id' on the input (${inputId}).`);
            return;
        }
        // If we don't have a valid id, generate one with lodash
        if (!inputId) {
            inputId = uniqueId$1(`sprk_input_`);
            this.renderer.setProperty(this.input.ref.nativeElement, 'id', inputId);
            this.renderer.setAttribute(this.label.ref.nativeElement, 'for', inputId);
        }
    }
    ngOnInit() {
        if (this.label && this.input) {
            this.generateIdForInput();
            this.addInputTypeClasses();
        }
    }
};
SprkSelectionItemContainerComponent.ctorParameters = () => [
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkSelectionItemContainerComponent.prototype, "additionalClasses", void 0);
__decorate([
    ContentChild(SprkSelectionLabelDirective, { static: true }),
    __metadata("design:type", SprkSelectionLabelDirective)
], SprkSelectionItemContainerComponent.prototype, "label", void 0);
__decorate([
    ContentChild(SprkSelectionInputDirective, { static: true }),
    __metadata("design:type", SprkSelectionInputDirective)
], SprkSelectionItemContainerComponent.prototype, "input", void 0);
SprkSelectionItemContainerComponent = __decorate([
    Component({
        selector: 'sprk-selection-item-container',
        template: `
    <div [ngClass]="getClasses()">
      <ng-content select="[sprkSelectionInput]"></ng-content>
      <ng-content select="[sprkSelectionLabel]"></ng-content>
      <ng-content></ng-content>
    </div>
  `
    }),
    __metadata("design:paramtypes", [Renderer2])
], SprkSelectionItemContainerComponent);

let SprkSelectionContainerComponent = class SprkSelectionContainerComponent {
    constructor() {
        /**
         * @ignore
         */
        this.id = uniqueId();
        /**
         * @ignore
         */
        this.error_id = `error_${this.id}`;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-InputContainer'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    ngAfterContentInit() {
        if (this.selectionItems && this.error) {
            this.selectionItems.forEach(item => {
                item.input.ref.nativeElement.setAttribute('aria-describedby', this.error_id);
            });
            this.error.ref.nativeElement.id = this.error_id;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkSelectionContainerComponent.prototype, "additionalClasses", void 0);
__decorate([
    ContentChild(SprkLabelDirective, { static: false }),
    __metadata("design:type", SprkLabelDirective)
], SprkSelectionContainerComponent.prototype, "label", void 0);
__decorate([
    ContentChild(SprkFieldErrorDirective, { static: false }),
    __metadata("design:type", SprkFieldErrorDirective)
], SprkSelectionContainerComponent.prototype, "error", void 0);
__decorate([
    ContentChildren(SprkSelectionItemContainerComponent),
    __metadata("design:type", QueryList)
], SprkSelectionContainerComponent.prototype, "selectionItems", void 0);
SprkSelectionContainerComponent = __decorate([
    Component({
        selector: 'sprk-selection-container',
        template: `
    <div [ngClass]="getClasses()">
      <fieldset class="sprk-b-Fieldset">
        <legend class="sprk-b-Legend">
          <ng-content select="[sprkLabel]"></ng-content>
        </legend>
        <ng-content select="sprk-selection-item-container"></ng-content>
      </fieldset>
      <ng-content select="[sprkHelperText]"></ng-content>
      <ng-content select="[sprkFieldError]"></ng-content>
      <ng-content></ng-content>
    </div>
  `
    })
], SprkSelectionContainerComponent);

let SprkSelectionContainerModule = class SprkSelectionContainerModule {
};
SprkSelectionContainerModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, FormsModule, ReactiveFormsModule],
        declarations: [SprkSelectionContainerComponent],
        exports: [SprkSelectionContainerComponent]
    })
], SprkSelectionContainerModule);

let SprkSelectionItemContainerModule = class SprkSelectionItemContainerModule {
};
SprkSelectionItemContainerModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, FormsModule, ReactiveFormsModule],
        declarations: [SprkSelectionItemContainerComponent],
        exports: [SprkSelectionItemContainerComponent]
    })
], SprkSelectionItemContainerModule);

let SprkIconComponent = class SprkIconComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Icon'];
        this.icon = `#${this.iconType}`;
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkIconComponent.prototype, "iconType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkIconComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkIconComponent.prototype, "idString", void 0);
SprkIconComponent = __decorate([
    Component({
        selector: 'sprk-icon',
        template: `
    <svg [ngClass]="getClasses()" viewBox="0 0 64 64" [attr.data-id]="idString">
      <use [attr.xlink:href]="icon" />
    </svg>
  `,
        styles: [':host { line-height: 1; }']
    })
], SprkIconComponent);

let SprkIconModule = class SprkIconModule {
};
SprkIconModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkIconComponent],
        exports: [SprkIconComponent]
    })
], SprkIconModule);

let SprkLinkDirective = class SprkLinkDirective {
    /**
     * @ignore
     */
    constructor(renderer, el) {
        this.renderer = renderer;
        this.el = el;
    }
    ngOnInit() {
        if (this.variant !== 'unstyled') {
            this.renderer.addClass(this.el.nativeElement, 'sprk-b-Link');
        }
        if (this.variant === 'simple' || this.variant === 'icon') {
            this.renderer.addClass(this.el.nativeElement, 'sprk-b-Link--simple');
        }
        if (this.variant === 'icon') {
            this.renderer.addClass(this.el.nativeElement, 'sprk-b-Link--has-icon');
        }
        if (this.variant === 'plain') {
            this.renderer.addClass(this.el.nativeElement, 'sprk-b-Link--plain');
        }
    }
};
SprkLinkDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkDirective.prototype, "variant", void 0);
__decorate([
    HostBinding('class.sprk-b-Link--disabled'),
    Input(),
    __metadata("design:type", Boolean)
], SprkLinkDirective.prototype, "isDisabled", void 0);
__decorate([
    HostBinding('attr.data-analytics'),
    Input(),
    __metadata("design:type", String)
], SprkLinkDirective.prototype, "analyticsString", void 0);
__decorate([
    HostBinding('attr.data-id'),
    Input(),
    __metadata("design:type", String)
], SprkLinkDirective.prototype, "idString", void 0);
SprkLinkDirective = __decorate([
    Directive({
        selector: '[sprkLink]'
    }),
    __metadata("design:paramtypes", [Renderer2, ElementRef])
], SprkLinkDirective);

let SprkLinkDirectiveModule = class SprkLinkDirectiveModule {
};
SprkLinkDirectiveModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [SprkLinkDirective],
        exports: [SprkLinkDirective]
    })
], SprkLinkDirectiveModule);

const toggleAnimations = {
    toggleContent: trigger('toggleContent', [
        state('closed', style({
            height: '0',
            overflow: 'hidden',
            visibility: 'hidden',
        })),
        state('open', style({
            height: '*',
            visibility: 'visible',
        })),
        transition('open <=> closed', animate('300ms ease-in'))
    ])
};

let SprkAccordionItemComponent = class SprkAccordionItemComponent {
    constructor() {
        /**
         * The Accordion item will use this to decide
         * if it should be open or closed on first render.
         * (Interacting with the toggle will override this input.)
         */
        this.isOpen = false;
        /**
         * The name of the icon to use for
         * a closed Accordion item.
         */
        this.iconTypeClosed = 'chevron-up-circle-two-color';
        /**
         * The name of the icon to use for
         * an open Accordion item.
         */
        this.iconTypeOpen = 'chevron-up-circle-two-color';
        /**
         * @ignore
         */
        this.componentID = uniqueId();
        /**
         * @ignore
         */
        this.accordion_controls_id = `accordionHeading__${this.componentID}`;
        /**
         * @ignore
         */
        this.currentIconType = this.iconTypeClosed;
        /**
         * @ignore
         */
        this.iconStateClass = '';
        /**
         * @ignore
         */
        this.animState = 'closed';
    }
    /**
     * @ignore
     */
    accordionState() {
        this.isOpen === false
            ? (this.animState = 'closed')
            : (this.animState = 'open');
        this.isOpen === false
            ? (this.currentIconType = this.iconTypeClosed)
            : (this.currentIconType = this.iconTypeOpen);
        this.isOpen === false
            ? (this.iconStateClass = '')
            : (this.iconStateClass = 'sprk-c-Icon--open');
    }
    /**
     * @ignore
     */
    toggleAccordion(event) {
        event.preventDefault();
        this.isOpen = !this.isOpen;
        this.accordionState();
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-c-Accordion__item',
            'sprk-u-Overflow--hidden'
        ];
        if (this.isOpen) {
            classArray.push('sprk-c-Accordion__item--open');
        }
        if (this.isActive) {
            classArray.push('sprk-c-Accordion__item--active');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getHeadingClasses() {
        const classArray = ['sprk-c-Accordion__heading'];
        if (this.additionalHeadingClasses) {
            this.additionalHeadingClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    ngOnInit() {
        this.accordionState();
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAccordionItemComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAccordionItemComponent.prototype, "analyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAccordionItemComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAccordionItemComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAccordionItemComponent.prototype, "additionalHeadingClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkAccordionItemComponent.prototype, "isOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkAccordionItemComponent.prototype, "isActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkAccordionItemComponent.prototype, "iconTypeClosed", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkAccordionItemComponent.prototype, "iconTypeOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAccordionItemComponent.prototype, "leadingIcon", void 0);
SprkAccordionItemComponent = __decorate([
    Component({
        selector: 'sprk-accordion-item',
        template: `
    <li [ngClass]="getClasses()">
      <button
        sprkLink
        variant="unstyled"
        href="#"
        [attr.aria-controls]="accordion_controls_id"
        [attr.aria-expanded]="isOpen"
        class="sprk-c-Accordion__summary"
        [analyticsString]="analyticsString"
        [idString]="idString"
        (click)="toggleAccordion($event)"
      >
        <span [ngClass]="getHeadingClasses()">
          <sprk-icon
            [iconType]="leadingIcon"
            additionalClasses="sprk-c-Icon--stroke-current-color sprk-c-Icon--l sprk-u-mrs"
            *ngIf="leadingIcon"
          ></sprk-icon>
          {{ title }}
        </span>

        <sprk-icon
          additionalClasses="sprk-c-Accordion__icon sprk-c-Icon--toggle sprk-c-Icon--l {{
            iconStateClass
          }}"
          [iconType]="currentIconType"
        ></sprk-icon>
      </button>

      <div [@toggleContent]="animState">
        <div
          [id]="accordion_controls_id"
          class="sprk-c-Accordion__content sprk-b-TypeBodyTwo"
        >
          <ng-content></ng-content>
        </div>
      </div>
    </li>
  `,
        animations: [toggleAnimations.toggleContent]
    })
], SprkAccordionItemComponent);

let SprkAccordionItemModule = class SprkAccordionItemModule {
};
SprkAccordionItemModule = __decorate([
    NgModule({
        imports: [CommonModule, SprkIconModule, SprkLinkDirectiveModule],
        declarations: [SprkAccordionItemComponent],
        exports: [SprkAccordionItemComponent]
    })
], SprkAccordionItemModule);

let SprkLinkComponent = 
/**
 * @deprecate This component will be removed in
 * a future release in favor of the `sprkLink` directive.
 * Please use the Spark Link
 * directive.
 */
class SprkLinkComponent {
    /**
     * @ignore
     */
    constructor(router) {
        this.router = router;
        /**
         * By default, the component determines if
         * the `href` is an external or internal link
         * by looking for the `:` character in the
         * `href` string. If external link functionality
         * is desired with an `href` value that contains
         * a `:` set this input to true. This overrides
         * the default and avoids using the Angular Router.
         */
        this.isExternal = false;
    }
    ngOnInit() {
        // This message is split up like this so that we can keep the line
        // length down in the editor while also logging a single unformatted
        // line of text in the console.
        const message = 'Spark Design System Warning: Spark Link has been ' +
            'refactored to be an Angular Directive. The old Angular Component ' +
            'version has been deprecated. This version will be permanently removed ' +
            'from Spark in our Summer 2020 release. To update to the new version, ' +
            'replace any instance of the <sprk-link> component in your codebase with ' +
            'the new Directive syntax.';
        console.warn(message);
        // Sets the default href if none provided
        if (this.href === '' || this.href === null || this.href === undefined) {
            this.href = '#';
            return;
        }
        // Build jump link's href
        if (this.isJumpLink(this.href)) {
            this.href = `${this.getPathWithoutHash(this.router.url)}${this.href}`;
        }
    }
    /**
     * @ignore
     */
    isExternalLink(value) {
        return new RegExp('^.*:', 'i').test(value);
    }
    /**
     * @ignore
     */
    isJumpLinkWithPage(value) {
        return new RegExp('^.*#.+', 'i').test(value);
    }
    /**
     * @ignore
     */
    isJumpLink(value) {
        return new RegExp('^#.+', 'i').test(value);
    }
    /**
     * @ignore
     */
    isNoActionLink(value) {
        return value === '#';
    }
    /**
     * @ignore
     */
    getPathWithoutHash(value) {
        return value.split('#')[0];
    }
    /**
     * @ignore
     */
    scrollToId() {
        const elementID = this.href.split('#').pop();
        const element = document.getElementById(elementID);
        if (element) {
            element.scrollIntoView();
        }
    }
    /**
     * @ignore
     */
    handleClick(event) {
        // Let browser handle route if external Link
        if (this.isExternalLink(this.href) || this.isExternal) {
            return;
        }
        event.preventDefault();
        // Prevent default and return
        if (this.isNoActionLink(this.href)) {
            return;
        }
        else if (this.isJumpLinkWithPage(this.href)) {
            if (this.getPathWithoutHash(this.href) ===
                this.getPathWithoutHash(this.router.url)) {
                this.scrollToId();
            }
            else {
                this.router.navigateByUrl(this.href);
            }
        }
        else {
            this.router.navigateByUrl(this.href);
        }
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [];
        switch (this.linkType) {
            case 'unstyled':
                break;
            case 'simple':
                classArray.push('sprk-b-Link sprk-b-Link--simple');
                break;
            case 'plain':
                classArray.push('sprk-b-Link sprk-b-Link--plain');
                break;
            case 'icon':
                classArray.push('sprk-b-Link sprk-b-Link--simple sprk-b-Link--has-icon');
                break;
            default:
                classArray.push('sprk-b-Link');
                break;
        }
        if (this.isDisabled) {
            classArray.push('sprk-b-Link--disabled');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
SprkLinkComponent.ctorParameters = () => [
    { type: Router }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "linkType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "href", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "role", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "ariaControls", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "ariaLabelledby", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "ariaSelected", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "ariaHidden", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "ariaCurrent", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "ariaExpanded", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "ariaHasPopUp", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "ariaLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "analyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "target", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkLinkComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkLinkComponent.prototype, "isDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkLinkComponent.prototype, "isExternal", void 0);
SprkLinkComponent = __decorate([
    Component({
        selector: 'sprk-link',
        template: `
    <a
      (click)="handleClick($event)"
      [ngClass]="getClasses()"
      [href]="href"
      [attr.data-analytics]="analyticsString"
      [attr.target]="target"
      [attr.data-id]="idString"
      [attr.disabled]="isDisabled"
      [attr.aria-controls]="ariaControls"
      [attr.aria-label]="ariaLabel"
      [attr.aria-labelledby]="ariaLabelledby"
      [attr.aria-haspopup]="ariaHasPopUp"
      [attr.role]="role"
      [attr.id]="id"
      [attr.aria-current]="ariaCurrent"
      [attr.aria-expanded]="ariaExpanded"
      [attr.aria-hidden]="ariaHidden"
      [attr.aria-selected]="ariaSelected"
    >
      <ng-content></ng-content>
    </a>
  `
    })
    /**
     * @deprecate This component will be removed in
     * a future release in favor of the `sprkLink` directive.
     * Please use the Spark Link
     * directive.
     */
    ,
    __metadata("design:paramtypes", [Router])
], SprkLinkComponent);

let SprkLinkModule = class SprkLinkModule {
};
SprkLinkModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkLinkComponent],
        exports: [SprkLinkComponent]
    })
], SprkLinkModule);

let SprkAccordionComponent = class SprkAccordionComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Accordion', 'sprk-o-VerticalList'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAccordionComponent.prototype, "additionalClasses", void 0);
SprkAccordionComponent = __decorate([
    Component({
        selector: 'sprk-accordion',
        template: `
    <ul [ngClass]="getClasses()">
      <ng-content></ng-content>
    </ul>
  `
    })
], SprkAccordionComponent);

let SprkAccordionModule = class SprkAccordionModule {
};
SprkAccordionModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, SprkIconModule, SprkLinkModule],
        declarations: [SprkAccordionComponent],
        exports: [SprkAccordionComponent]
    })
], SprkAccordionModule);

let SprkAlertComponent = class SprkAlertComponent {
    constructor() {
        /**
         * @ignore
         */
        this.visible = true;
    }
    /**
     * @ignore
     */
    getClassesAlertContainer() {
        const alertClassArray = ['sprk-c-Alert'];
        switch (this.alertType) {
            case 'success':
                alertClassArray.push('sprk-c-Alert--success');
                this.icon = 'check-mark';
                break;
            case 'info':
                alertClassArray.push('sprk-c-Alert--info');
                this.icon = 'bell';
                break;
            case 'fail':
                alertClassArray.push('sprk-c-Alert--fail');
                this.icon = 'exclamation';
                break;
            default:
                break;
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                alertClassArray.push(className);
            });
        }
        return alertClassArray.join(' ');
    }
    /**
     * When the dismiss button is clicked
     * this method sets the visable state to `false`
     * and hides the Alert component.
     */
    alertDismiss(event) {
        this.visible = false;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAlertComponent.prototype, "alertType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAlertComponent.prototype, "analyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAlertComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAlertComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkAlertComponent.prototype, "dismissible", void 0);
SprkAlertComponent = __decorate([
    Component({
        selector: 'sprk-alert',
        template: `
    <div
      *ngIf="visible"
      [ngClass]="getClassesAlertContainer()"
      role="alert"
      [attr.data-analytics]="analyticsString"
      [attr.data-id]="idString"
    >
      <div class="sprk-c-Alert__content">
        <sprk-icon
          iconType="{{ icon }}"
          additionalClasses="sprk-c-Alert__icon sprk-c-Icon--l sprk-c-Icon--stroke-current-color"
          aria-hidden="true"
        ></sprk-icon>

        <p class="sprk-c-Alert__text"><ng-content></ng-content></p>
      </div>

      <button
        *ngIf="dismissible !== false"
        class="sprk-c-Alert__icon sprk-c-Alert__icon--dismiss"
        type="button"
        title="Dismiss"
        (click)="alertDismiss($event)"
      >
        <sprk-icon
          iconType="close"
          additionalClasses="sprk-c-Icon--stroke-current-color"
          aria-hidden="true"
        ></sprk-icon>
      </button>
    </div>
  `
    })
], SprkAlertComponent);

let SprkAlertModule = class SprkAlertModule {
};
SprkAlertModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, SprkIconModule],
        declarations: [SprkAlertComponent],
        exports: [SprkAlertComponent]
    })
], SprkAlertModule);

let SprkDividerComponent = class SprkDividerComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Divider'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDividerComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDividerComponent.prototype, "idString", void 0);
SprkDividerComponent = __decorate([
    Component({
        selector: 'sprk-divider',
        template: `
    <span [ngClass]="getClasses()" [attr.data-id]="idString"> </span>
  `
    })
], SprkDividerComponent);

let SprkDividerModule = class SprkDividerModule {
};
SprkDividerModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkDividerComponent],
        exports: [SprkDividerComponent]
    })
], SprkDividerModule);

let SprkDropdownComponent = class SprkDropdownComponent {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
        /**
         * The variant of the Dropdown to render.
         */
        this.dropdownType = 'base';
        /**
         * If `true`, the Dropdown will be open when rendered.
         */
        this.isOpen = false;
        /**
         * The event that is
         * emitted from the Dropdown when a choice
         * is clicked. The event contains the value
         * of the choice that was clicked.
         */
        this.choiceMade = new EventEmitter();
    }
    /**
     * @ignore
     */
    toggle(event) {
        event.preventDefault();
        this.isOpen = !this.isOpen;
    }
    onClick(event) {
        if (!this.ref.nativeElement.contains(event.target) ||
            event.target.classList.contains('sprk-c-MastheadMask')) {
            this.hideDropdown();
        }
    }
    onFocusin(event) {
        /* istanbul ignore else: angular focus event isnt setting e.target */
        if (!this.ref.nativeElement.contains(event.target) ||
            event.target.classList.contains('sprk-c-MastheadMask')) {
            this.hideDropdown();
        }
    }
    /**
     * @ignore
     */
    choiceClick(event) {
        this.clearActiveChoices();
        const choiceIndex = event.currentTarget.getAttribute('data-sprk-dropdown-choice-index');
        const clickedChoice = this.choices[choiceIndex];
        if (this.dropdownType === 'informational' ||
            this.dropdownType === 'mastheadSelector') {
            this.setActiveChoice(event);
            this.updateTriggerText(event);
        }
        this.hideDropdown();
        this.choiceMade.emit(clickedChoice['value']);
    }
    /**
     * @ignore
     */
    setActiveChoice(event) {
        const choiceIndex = event.currentTarget.getAttribute('data-sprk-dropdown-choice-index');
        this.choices[choiceIndex]['active'] = true;
    }
    /**
     * @ignore
     */
    updateTriggerText(event) {
        const choiceIndex = event.currentTarget.getAttribute('data-sprk-dropdown-choice-index');
        this.triggerText = this.choices[choiceIndex]['value'];
    }
    /**
     * @ignore
     */
    clearActiveChoices() {
        this.choices.forEach((choice) => {
            choice['active'] = false;
        });
    }
    /**
     * @ignore
     */
    hideDropdown() {
        this.isOpen = false;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Dropdown'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getTriggerClasses() {
        const classArray = [];
        if (this.additionalTriggerClasses) {
            this.additionalTriggerClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getTriggerTextClasses() {
        const classArray = [''];
        if (this.additionalTriggerTextClasses) {
            this.additionalTriggerTextClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
SprkDropdownComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkDropdownComponent.prototype, "dropdownType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "additionalIconClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "additionalTriggerClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "additionalTriggerTextClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "analyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkDropdownComponent.prototype, "isOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "selector", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkDropdownComponent.prototype, "choices", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "triggerIconType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "triggerText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDropdownComponent.prototype, "screenReaderText", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], SprkDropdownComponent.prototype, "choiceMade", void 0);
__decorate([
    HostListener('document:click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkDropdownComponent.prototype, "onClick", null);
__decorate([
    HostListener('document:focusin', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkDropdownComponent.prototype, "onFocusin", null);
SprkDropdownComponent = __decorate([
    Component({
        selector: 'sprk-dropdown',
        template: `
    <div
      [ngClass]="{
        'sprk-c-MastheadMask': isOpen && dropdownType === 'mastheadSelector'
      }"
    >
      <div [ngClass]="{ 'sprk-o-Box': dropdownType === 'mastheadSelector' }">
        <a
          sprkLink
          [ngClass]="getTriggerClasses()"
          (click)="toggle($event)"
          [idString]="idString"
          [analyticsString]="analyticsString"
          aria-haspopup="listbox"
          href="#"
          [attr.aria-label]="triggerText ? triggerText : (screenReaderText || 'Choose One')"
        >
          <span [ngClass]="getTriggerTextClasses()">{{ triggerText }}</span>
          <span class="sprk-u-ScreenReaderText">{{ screenReaderText }}</span>
          <sprk-icon
            [iconType]="triggerIconType"
            additionalClasses="sprk-u-mls sprk-c-Icon--stroke-current-color {{
              additionalIconClasses
            }}"
          ></sprk-icon>
        </a>
      </div>

      <div [ngClass]="getClasses()" *ngIf="isOpen">
        <div
          class="sprk-c-Dropdown__header"
          *ngIf="dropdownType === 'mastheadSelector' || title || selector"
        >
          <h2 class="sprk-c-Dropdown__title sprk-b-TypeBodyTwo" *ngIf="title">
            {{ title }}
          </h2>

          <a
            sprkLink
            *ngIf="selector && !title"
            variant="plain"
            class="sprk-o-Stack sprk-o-Stack--split@xxs sprk-o-Stack--center-column sprk-u-Width-100"
            (click)="toggle($event)"
            [attr.aria-label]="title"
            href="#"
          >
            <span
              class="sprk-c-Dropdown__title sprk-b-TypeBodyTwo sprk-o-Stack__item sprk-o-Stack__item--flex@xxs"
              >{{ selector }}</span
            >
            <sprk-icon
              [iconType]="triggerIconType"
              additionalClasses="sprk-c-Icon--stroke-current-color sprk-u-mls sprk-c-Icon--toggle sprk-Stack__item {{
                additionalIconClasses
              }}"
            ></sprk-icon>
          </a>
        </div>

        <ul
          class="sprk-c-Dropdown__links"
          role="listbox"
          [attr.aria-label]="title ? title : (screenReaderText || 'My Choices')"
        >
          <li
            class="sprk-c-Dropdown__item"
            *ngFor="let choice of choices; let i = index"
            [attr.data-sprk-dropdown-choice-index]="i"
            (click)="choiceClick($event)"
            [attr.aria-selected]="choice.active"
            role="option"
          >
            <div *ngIf="choice.content; then content; else link"></div>
            <ng-template #link>
              <a
                sprkLink
                variant="unstyled"
                [attr.href]="choice.href"
                [analyticsString]="choice.analyticsString"
                [ngClass]="{
                  'sprk-c-Dropdown__link': true,
                  'sprk-c-Dropdown__link--active': choice.active
                }"
                [attr.aria-label]="choice.text"
                >{{ choice.text }}
              </a>
            </ng-template>
            <ng-template #content>
              <a
                sprkLink
                variant="unstyled"
                [attr.href]="choice.href"
                [analyticsString]="choice.analyticsString"
                [ngClass]="{
                  'sprk-c-Dropdown__link': true,
                  'sprk-c-Dropdown__link--active': choice.active
                }"
                [attr.aria-label]="choice.content.title"
              >
                <p class="sprk-b-TypeBodyOne">{{ choice.content.title }}</p>
                <p>{{ choice.content.infoLine1 }}</p>
                <p>{{ choice.content.infoLine2 }}</p>
              </a>
            </ng-template>
          </li>
        </ul>
        <ng-content select="[sprkDropdownFooter]"></ng-content>
      </div>
    </div>
  `
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkDropdownComponent);

let SprkDropdownModule = class SprkDropdownModule {
};
SprkDropdownModule = __decorate([
    NgModule({
        imports: [CommonModule, SprkIconModule, SprkLinkDirectiveModule],
        declarations: [SprkDropdownComponent],
        exports: [SprkDropdownComponent]
    })
], SprkDropdownModule);

let SprkStackComponent = class SprkStackComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-o-Stack'];
        // Handle the choice of item split breakpoint by adding CSS class
        switch (this.splitAt) {
            case 'tiny':
                classArray.push('sprk-o-Stack--split@xs');
                break;
            case 'small':
                classArray.push('sprk-o-Stack--split@s');
                break;
            case 'medium':
                classArray.push('sprk-o-Stack--split@m');
                break;
            case 'large':
                classArray.push('sprk-o-Stack--split@l');
                break;
            case 'huge':
                classArray.push('sprk-o-Stack--split@xl');
                break;
            default:
                break;
        }
        // Handle the choice of item spacing by adding CSS class
        switch (this.itemSpacing) {
            case 'tiny':
                classArray.push('sprk-o-Stack--tiny');
                break;
            case 'small':
                classArray.push('sprk-o-Stack--small');
                break;
            case 'medium':
                classArray.push('sprk-o-Stack--medium');
                break;
            case 'large':
                classArray.push('sprk-o-Stack--large');
                break;
            case 'huge':
                classArray.push('sprk-o-Stack--huge');
                break;
            default:
                break;
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkStackComponent.prototype, "splitAt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkStackComponent.prototype, "itemSpacing", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkStackComponent.prototype, "analyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkStackComponent.prototype, "additionalClasses", void 0);
SprkStackComponent = __decorate([
    Component({
        selector: 'sprk-stack',
        template: `
    <div [ngClass]="getClasses()" [attr.data-analytics]="analyticsString">
      <ng-content></ng-content>
    </div>
  `
    })
], SprkStackComponent);

let SprkStackModule = class SprkStackModule {
};
SprkStackModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkStackComponent],
        exports: [SprkStackComponent]
    })
], SprkStackModule);

let SprkToggleComponent = class SprkToggleComponent {
    constructor() {
        /**
         * The value supplied will be assigned as a CSS class
         * on the clickable title text used in the Toggle.
         * This is intended for overrides.
         */
        this.titleFontClass = 'sprk-b-TypeBodyThree';
        /**
         * A string that is used to set the `id` on the content
         * and the `aria-controls` for the toggle trigger button.
         */
        this.contentId = uniqueId(`sprk_toggle_content_`);
        /**
         * @ignore
         */
        this.isOpen = false;
        /**
         * @ignore
         */
        this.iconStateClass = '';
        /**
         * @ignore
         */
        this.animState = 'closed';
    }
    /**
     * @ignore
     */
    toggleState() {
        this.isOpen === false
            ? (this.animState = 'closed')
            : (this.animState = 'open');
        this.isOpen === false
            ? (this.iconStateClass = '')
            : (this.iconStateClass = 'sprk-c-Icon--open');
    }
    /**
     * @ignore
     */
    toggle(event) {
        event.preventDefault();
        this.isOpen = !this.isOpen;
        this.toggleState();
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-c-Toggle__trigger sprk-u-TextCrop--none',
            this.titleFontClass,
        ];
        return classArray.join(' ');
    }
    ngAfterViewInit() {
        this.toggleState();
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkToggleComponent.prototype, "analyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkToggleComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkToggleComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkToggleComponent.prototype, "iconClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkToggleComponent.prototype, "titleFontClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkToggleComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkToggleComponent.prototype, "contentId", void 0);
SprkToggleComponent = __decorate([
    Component({
        selector: 'sprk-toggle',
        template: `
    <div
      class="sprk-c-Toggle {{ additionalClasses }}"
      [attr.data-id]="idString"
    >
      <button
        variant="icon"
        [ngClass]="getClasses()"
        (click)="toggle($event)"
        [attr.aria-expanded]="isOpen ? 'true' : 'false'"
        [attr.data-analytics]="analyticsString"
        [attr.aria-controls]="contentId"
      >
        <sprk-icon
          iconType="chevron-down-circle-two-color"
          additionalClasses="{{
            iconClass
          }} sprk-c-Icon--l sprk-u-mrs sprk-c-Icon--toggle {{ iconStateClass }}"
        ></sprk-icon>
        {{ title }}
      </button>

      <div
        [@toggleContent]="animState"
        [id]="contentId"
      >
        <div class="sprk-u-pts sprk-u-pbs sprk-c-Toggle__content">
          <ng-content></ng-content>
        </div>
      </div>
    </div>
  `,
        animations: [toggleAnimations.toggleContent]
    })
], SprkToggleComponent);

let SprkToggleModule = class SprkToggleModule {
};
SprkToggleModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            SprkIconModule,
            SprkLinkDirectiveModule
        ],
        declarations: [SprkToggleComponent],
        exports: [SprkToggleComponent]
    })
], SprkToggleModule);

let SprkFooterComponent = class SprkFooterComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-o-CenteredColumn sprk-o-Stack sprk-o-Stack--misc-b'
        ];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFooterComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFooterComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFooterComponent.prototype, "globalHeading", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFooterComponent.prototype, "awardsHeading", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFooterComponent.prototype, "connectHeading", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkFooterComponent.prototype, "globalLinks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkFooterComponent.prototype, "localLinks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkFooterComponent.prototype, "socialLinks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkFooterComponent.prototype, "awards", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkFooterComponent.prototype, "badgeLinks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkFooterComponent.prototype, "disclaimerText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkFooterComponent.prototype, "disclaimerToggle", void 0);
SprkFooterComponent = __decorate([
    Component({
        selector: 'sprk-footer',
        template: `
    <div class="sprk-o-Box sprk-o-Box--large sprk-u-BackgroundColor--gray">
      <footer
        [ngClass]="getClasses()"
        role="contentinfo"
        [attr.data-id]="idString"
      >
        <div
          class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--medium sprk-o-Stack--split@m"
        >
          <div
            *ngIf="globalLinks"
            class="sprk-o-Stack__item sprk-o-Stack__item--three-tenths@m sprk-o-Stack sprk-o-Stack--misc-b sprk-o-Box sprk-u-prh"
          >
            <h3 class="sprk-o-Stack__item sprk-b-TypeBodyOne">
              {{ globalHeading }}
            </h3>

            <div
              *ngFor="let item of globalLinks"
              class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--medium"
            >
              <div class="sprk-o-Stack__item">
                <a
                  sprkLink
                  variant="plain"
                  href="{{ item.href }}"
                  analyticsString="{{ item.analytics || item.analyticsString }}"
                >
                  <sprk-icon
                    *ngIf="item.icon"
                    iconType="{{ item.icon }}"
                    additionalClasses="{{ item.iconCSS }}"
                  ></sprk-icon>
                  <span *ngIf="item.icon" class="sprk-u-ScreenReaderText">{{
                    item.iconScreenReaderText
                  }}</span>
                  <img
                    *ngIf="item.imgSrc"
                    src="{{ item.imgSrc }}"
                    alt="{{ item.imgAlt }}"
                    class="{{ item.imgCSS }}"
                  />
                </a>
              </div>

              <p class="sprk-o-Stack__item sprk-b-TypeBodyFour">
                {{ item.text }}
              </p>
            </div>
          </div>

          <div
            class="sprk-o-Stack__item sprk-o-Stack__item--seven-tenths@m sprk-o-Stack sprk-o-Stack--medium"
          >
            <div
              *ngIf="localLinks"
              class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--medium sprk-o-Stack--split@m"
            >
              <div
                *ngFor="let item of localLinks"
                class="sprk-o-Stack__item sprk-o-Stack__item--third@m sprk-o-Box sprk-u-PaddingRight--a sprk-o-Stack sprk-o-Stack--large"
              >
                <h3 class="sprk-o-Stack__item sprk-b-TypeBodyOne">
                  {{ item.heading }}
                </h3>

                <ul
                  class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--misc-a sprk-b-List sprk-b-List--bare"
                >
                  <li
                    class="sprk-o-Stack__item"
                    *ngFor="let link of item.links"
                  >
                    <a
                      sprkLink
                      variant="simple"
                      class="sprk-u-FontWeight--normal"
                      href="{{ link.href }}"
                      analyticsString="{{ link.analyticsString || link.analytics }}"
                    >
                      {{ link.text }}
                    </a>
                  </li>
                </ul>
              </div>
            </div>

            <div
              *ngIf="socialLinks"
              class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--large sprk-o-Box"
            >
              <h3 class="sprk-o-Stack__item sprk-b-TypeBodyOne">
                {{ connectHeading }}
              </h3>

              <div
                class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--large sprk-o-Stack--split@m"
              >
                <ul
                  *ngIf="socialLinks"
                  class="
                    sprk-o-Stack__item
                    sprk-o-Stack__item--flex@m
                    sprk-o-Stack
                    sprk-o-Stack--split@xxs
                    sprk-o-Stack--medium
                    sprk-b-List
                    sprk-b-List--bare"
                >
                  <li
                    *ngFor="let item of socialLinks"
                    class="sprk-o-Stack__item"
                  >
                    <a
                      sprkLink
                      variant="plain"
                      href="{{ item.href }}"
                      analyticsString="{{ item.analytics || item.analyticsString }}"
                    >
                      <sprk-icon
                        *ngIf="item.icon"
                        iconType="{{ item.icon }}"
                        additionalClasses="{{ item.iconCSS }}"
                      ></sprk-icon>
                      <span *ngIf="item.icon" class="sprk-u-ScreenReaderText">{{
                        item.iconScreenReaderText
                      }}</span>
                    </a>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <span
          class="sprk-c-Divider sprk-u-mvn sprk-u-mhm"
          data-id="divider-1"
        ></span>

        <div
          class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--misc-b sprk-o-Box sprk-u-PaddingTop--b"
        >
          <div
            *ngIf="awards"
            class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--large"
          >
            <h3 class="sprk-o-Stack__item sprk-b-TypeBodyOne">
              {{ awardsHeading }}
            </h3>

            <div
              class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--medium sprk-o-Stack--split@s sprk-u-mbm"
            >
              <div class="sprk-o-Stack__item" *ngFor="let award of awards">
                <a
                  sprkLink
                  variant="plain"
                  class="sprk-o-Stack__item"
                  href="{{ award.href }}"
                  analyticsString="{{ award.analytics || award.analyticsString }}"
                >
                  <img
                    *ngIf="award.imgSrc"
                    src="{{ award.imgSrc }}"
                    alt="{{ award.imgAlt }}"
                    class="{{ award.imgCSS }}"
                  />
                </a>
              </div>
            </div>

            <div
              *ngFor="let toggle of disclaimerToggle"
              class="sprk-o-Stack__item"
            >
              <sprk-toggle
                title="{{ toggle.title }}"
                analyticsString="{{ toggle.analytics || toggle.analyticsString }}"
                iconClass="sprk-c-Icon--stroke-current-color"
                titleFontClass="sprk-b-TypeBodyFour"
              >
                <p class="sprk-b-TypeBodyFour">{{ toggle.body }}</p>
              </sprk-toggle>
            </div>
          </div>

          <div
            *ngIf="disclaimerText"
            class="sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--large"
          >
            <p
              *ngFor="let disclaimer of disclaimerText"
              class="sprk-o-Stack__item sprk-b-TypeBodyFour"
            >
              {{ disclaimer.text }}
            </p>
          </div>

          <ul
            *ngIf="badgeLinks"
            class="
              sprk-o-Stack__item
              sprk-o-Stack__item--flex@m
              sprk-o-Stack
              sprk-o-Stack--split@xxs
              sprk-o-Stack--medium
              sprk-b-List
              sprk-b-List--bare"
          >
            <li *ngFor="let item of badgeLinks" class="sprk-o-Stack__item">
              <a
                sprkLink
                variant="plain"
                href="{{ item.href }}"
                analyticsString="{{ item.analytics || item.analyticsString }}"
              >
                <sprk-icon
                  *ngIf="item.icon"
                  iconType="{{ item.icon }}"
                  additionalClasses="{{ item.iconCSS }}"
                ></sprk-icon>
                <span *ngIf="item.icon" class="sprk-u-ScreenReaderText">{{
                  item.iconScreenReaderText
                }}</span>
              </a>
            </li>
          </ul>
        </div>
      </footer>
    </div>
  `
    })
], SprkFooterComponent);

let SprkFooterModule = class SprkFooterModule {
};
SprkFooterModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            SprkIconModule,
            SprkStackModule,
            SprkStackItemModule,
            SprkToggleModule,
            SprkLinkDirectiveModule
        ],
        declarations: [SprkFooterComponent],
        exports: [SprkFooterComponent]
    })
], SprkFooterModule);

let SprkListItemComponent = class SprkListItemComponent {
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkListItemComponent.prototype, "analyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkListItemComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkListItemComponent.prototype, "additionalClasses", void 0);
__decorate([
    ViewChild(TemplateRef, { static: true }),
    __metadata("design:type", TemplateRef)
], SprkListItemComponent.prototype, "content", void 0);
SprkListItemComponent = __decorate([
    Component({
        selector: 'sprk-list-item',
        template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `
    })
], SprkListItemComponent);

let SprkListItemModule = class SprkListItemModule {
};
SprkListItemModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkListItemComponent],
        exports: [SprkListItemComponent]
    })
], SprkListItemModule);

let SprkMastheadAccordionComponent = class SprkMastheadAccordionComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-c-MastheadAccordion',
            'sprk-b-List',
            'sprk-b-List--bare'
        ];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadAccordionComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadAccordionComponent.prototype, "idString", void 0);
SprkMastheadAccordionComponent = __decorate([
    Component({
        selector: 'sprk-masthead-accordion',
        template: `
    <nav role="navigation" [attr.data-id]="idString">
      <ul [ngClass]="getClasses()">
        <ng-content></ng-content>
      </ul>
    </nav>
  `
    })
], SprkMastheadAccordionComponent);

let SprkMastheadAccordionModule = class SprkMastheadAccordionModule {
};
SprkMastheadAccordionModule = __decorate([
    NgModule({
        imports: [CommonModule, SprkIconModule],
        declarations: [SprkMastheadAccordionComponent],
        exports: [SprkMastheadAccordionComponent]
    })
], SprkMastheadAccordionModule);

let SprkMastheadAccordionItemComponent = class SprkMastheadAccordionItemComponent {
    constructor() {
        /**
         * If `true`, the Masthead accordion item
         * will be open when it is rendered.
         */
        this.isOpen = false;
        /**
         * The name of the icon to use
         * for the clickable close icon.
         */
        this.iconTypeClosed = 'chevron-up-circle-two-color';
        /**
         * The name of the icon to use
         * for the clickable open icon.
         */
        this.iconTypeOpen = 'chevron-up-circle-two-color';
        /**
         * @ignore
         */
        this.componentID = uniqueId();
        /**
         * @ignore
         */
        this.accordion_controls_id = `accordionHeading__${this.componentID}`;
        /**
         * @ignore
         */
        this.currentIconType = this.iconTypeClosed;
        /**
         * @ignore
         */
        this.iconStateClass = '';
        /**
         * @ignore
         */
        this.animState = 'closed';
    }
    /**
     * @ignore
     */
    accordionState() {
        this.isOpen === false
            ? (this.animState = 'closed')
            : (this.animState = 'open');
        this.isOpen === false
            ? (this.currentIconType = this.iconTypeClosed)
            : (this.currentIconType = this.iconTypeOpen);
        this.isOpen === false
            ? (this.iconStateClass = '')
            : (this.iconStateClass = 'sprk-c-Icon--open');
    }
    /**
     * @ignore
     */
    toggleAccordion(event) {
        event.preventDefault();
        this.isOpen = !this.isOpen;
        this.accordionState();
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-c-MastheadAccordion__item',
            'sprk-u-Overflow--hidden'
        ];
        if (this.isOpen) {
            classArray.push('sprk-c-MastheadAccordion__item--open');
        }
        if (this.isActive) {
            classArray.push('sprk-c-MastheadAccordion__item--active');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getHeadingClasses() {
        const classArray = ['sprk-c-MastheadAccordion__heading'];
        if (this.additionalHeadingClasses) {
            this.additionalHeadingClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    ngOnInit() {
        this.accordionState();
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadAccordionItemComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadAccordionItemComponent.prototype, "analyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadAccordionItemComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadAccordionItemComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadAccordionItemComponent.prototype, "additionalHeadingClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkMastheadAccordionItemComponent.prototype, "isOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkMastheadAccordionItemComponent.prototype, "isActive", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkMastheadAccordionItemComponent.prototype, "iconTypeClosed", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkMastheadAccordionItemComponent.prototype, "iconTypeOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadAccordionItemComponent.prototype, "leadingIcon", void 0);
SprkMastheadAccordionItemComponent = __decorate([
    Component({
        selector: 'sprk-masthead-accordion-item',
        template: `
    <li [ngClass]="getClasses()">
      <div
        class="sprk-u-Position--relative sprk-o-Stack__item sprk-u-Width-100"
      >
        <button
          [attr.aria-controls]="accordion_controls_id"
          class="sprk-c-MastheadAccordion__summary"
          [attr.data-analytics]="analyticsString"
          [attr.data-id]="idString"
          (click)="toggleAccordion($event)"
          [attr.aria-expanded]="isOpen"
        >
          <span [ngClass]="getHeadingClasses()">
            <sprk-icon
              [iconType]="leadingIcon"
              additionalClasses="sprk-c-Icon--stroke-current-color sprk-c-Icon--l sprk-c-Icon--toggle sprk-u-mrs"
              *ngIf="leadingIcon"
            ></sprk-icon>
            {{ title }}
          </span>

          <sprk-icon
            additionalClasses="sprk-c-MastheadAccordion__icon sprk-c-Icon--stroke-current-color sprk-c-Icon--toggle {{
              iconStateClass
            }}"
            [iconType]="currentIconType"
          ></sprk-icon>
        </button>
      </div>

      <div [@toggleContent]="animState">
        <div [id]="accordion_controls_id"><ng-content></ng-content></div>
      </div>
    </li>
  `,
        animations: [toggleAnimations.toggleContent]
    })
], SprkMastheadAccordionItemComponent);

let SprkMastheadAccordionItemModule = class SprkMastheadAccordionItemModule {
};
SprkMastheadAccordionItemModule = __decorate([
    NgModule({
        imports: [CommonModule, SprkIconModule],
        declarations: [SprkMastheadAccordionItemComponent],
        exports: [SprkMastheadAccordionItemComponent]
    })
], SprkMastheadAccordionItemModule);

let SprkMastheadComponent = class SprkMastheadComponent {
    /**
     * @ignore
     */
    constructor(renderer, router) {
        this.renderer = renderer;
        /**
         *  The `href` value of the logo.
         */
        this.logoHref = '/';
        /**
         * The value supplied will be used as
         * screen reader text that is visually hidden
         * for the link that wraps the logo.
         */
        this.logoLinkScreenReaderText = 'Go to the homepage';
        /**
         * Represents the initial state of the
         * narrow nav element of the Masthead component.
         */
        this.isNarrowNavOpen = false;
        /**
         * A string that is used to set the `id` on the narrow nav
         * and the `aria-controls` for the menu trigger button.
         */
        this.narrowNavId = uniqueId(`sprk_masthead_narrow_nav_`);
        /**
         * @ignore
         */
        this.iconType = 'chevron-down';
        /**
         * @ignore
         */
        this.componentID = uniqueId();
        /**
         * @ignore
         */
        this.controls_id = `sprk-narrow-navigation-item__${this.componentID}`;
        /**
         * @ignore
         */
        this.isScrolled = false;
        /**
         * @ignore
         */
        this.isNarrowLayout = false;
        /**
         * @ignore
         */
        this.scrollDirection = 'up';
        /**
         * @ignore
         */
        this.isHidden = false;
        /**
         * @ignore
         */
        this.isNarrowOnResize = false;
        /**
         * @ignore
         */
        this.scrollPosition = 0;
        /**
         * @ignore
         */
        this.throttledCheckScrollDirection = throttle(this.checkScrollDirection, 500);
        /**
         * @ignore
         */
        this.throttledUpdateLayoutState = throttle(this.updateLayoutState, 500);
        router.events.subscribe((event) => {
            if (event instanceof NavigationEnd) {
                this.closeNarrowNav();
            }
        });
    }
    /**
     * @ignore
     * Closes the narrow navigation menu
     * if it is left open when
     * the viewport is expanded.
     */
    handleResizeEvent() {
        this.closeNarrowNav();
    }
    /**
     * @ignore
     */
    onScroll(event) {
        window.scrollY >= 10 ? (this.isScrolled = true) : (this.isScrolled = false);
        if (this.isNarrowLayout) {
            this.throttledCheckScrollDirection();
        }
    }
    /**
     * @ignore
     * Handles when viewport size changes to
     * large while narrow nav is hidden.
     */
    onResize(event) {
        this.isNarrowOnResize = this.isElementVisible('.sprk-c-Masthead__menu');
        this.throttledUpdateLayoutState();
    }
    /**
     * @ignore
     */
    updateLayoutState() {
        if (this.isNarrowLayout !== this.isNarrowOnResize) {
            this.isNarrowLayout = this.isNarrowOnResize;
            // If is not narrow on resize update, make sure it's visible
            if (!this.isNarrowLayout) {
                this.isHidden = false;
            }
        }
    }
    /**
     * @ignore
     */
    ngAfterContentInit() {
        this.isNarrowLayout = this.isElementVisible('.sprk-c-Masthead__menu');
    }
    /**
     * @ignore
     */
    isElementVisible(selector) {
        if (typeof window === 'undefined') {
            return;
        }
        const element = document.querySelector(selector);
        if (!element) {
            return;
        }
        const elementDisplayValue = window.getComputedStyle(element).display;
        const elementVisibilityValue = window.getComputedStyle(element).visibility;
        const elementIsVisible = elementDisplayValue === 'none' || elementVisibilityValue === 'hidden'
            ? false
            : true;
        return elementIsVisible;
    }
    /**
     * @ignore
     */
    scrollYDirection() {
        if (typeof window !== 'undefined') {
            const newScrollPos = window.scrollY;
            if (newScrollPos < 0) {
                return;
            }
            const diff = newScrollPos - this.scrollPosition;
            const direction = diff > 0 ? 'down' : 'up';
            this.scrollPosition = newScrollPos;
            return direction;
        }
    }
    /**
     * @ignore
     */
    checkScrollDirection() {
        const newDirection = this.scrollYDirection();
        if (this.scrollDirection !== newDirection) {
            this.scrollDirection = newDirection;
            this.scrollDirection === 'down'
                ? (this.isHidden = true)
                : (this.isHidden = false);
        }
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Masthead', 'sprk-o-Stack'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        if (this.isNarrowNavOpen) {
            classArray.push('sprk-c-Masthead--open');
        }
        if (this.isScrolled) {
            classArray.push('sprk-c-Masthead--scroll');
        }
        if (this.isHidden) {
            classArray.push('sprk-c-Masthead--hidden');
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getNarrowNavClasses() {
        const classArray = [];
        if (this.additionalNarrowNavClasses) {
            this.additionalNarrowNavClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getSecondaryNavClasses() {
        const classArray = [
            'sprk-c-Masthead__big-nav-items',
            'sprk-o-Stack',
            'sprk-o-Stack--misc-a',
            'sprk-o-Stack--center-row',
            'sprk-o-Stack--split@xxs',
            'sprk-b-List',
            'sprk-b-List--bare'
        ];
        if (this.additionalBigNavClasses) {
            this.additionalBigNavClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    toggleNarrowNav(event) {
        event.preventDefault();
        if (this.isNarrowNavOpen) {
            this.closeNarrowNav();
        }
        else {
            this.openNarrowNav();
        }
    }
    /**
     * @ignore
     */
    openNarrowNav() {
        this.renderer.addClass(document.body, 'sprk-u-Overflow--hidden');
        this.renderer.addClass(document.body.parentElement, 'sprk-u-Overflow--hidden');
        this.renderer.addClass(document.body, 'sprk-u-Height--100');
        this.renderer.addClass(document.body.parentElement, 'sprk-u-Height--100');
        this.isNarrowNavOpen = true;
    }
    /**
     * @ignore
     */
    closeNarrowNav() {
        this.renderer.removeClass(document.body, 'sprk-u-Overflow--hidden');
        this.renderer.removeClass(document.body.parentElement, 'sprk-u-Overflow--hidden');
        this.renderer.removeClass(document.body, 'sprk-u-Height--100');
        this.renderer.removeClass(document.body.parentElement, 'sprk-u-Height--100');
        this.isNarrowNavOpen = false;
    }
};
SprkMastheadComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: Router }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkMastheadComponent.prototype, "logoHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkMastheadComponent.prototype, "logoLinkScreenReaderText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadComponent.prototype, "additionalBigNavClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadComponent.prototype, "additionalNarrowNavClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkMastheadComponent.prototype, "narrowNavLinks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkMastheadComponent.prototype, "isNarrowNavOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkMastheadComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SprkMastheadComponent.prototype, "bigNavLinks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkMastheadComponent.prototype, "narrowSelector", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkMastheadComponent.prototype, "narrowNavId", void 0);
__decorate([
    HostListener('window:orientationchange'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SprkMastheadComponent.prototype, "handleResizeEvent", null);
__decorate([
    HostListener('window:scroll', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkMastheadComponent.prototype, "onScroll", null);
__decorate([
    HostListener('window:resize', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkMastheadComponent.prototype, "onResize", null);
SprkMastheadComponent = __decorate([
    Component({
        selector: 'sprk-masthead',
        template: `
    <header [ngClass]="getClasses()" role="banner" [attr.data-id]="idString">
      <div
        class="sprk-c-Masthead__content sprk-o-Stack__item sprk-o-Stack sprk-o-Stack--split@xxs"
      >
        <div
          class="sprk-c-Masthead__menu sprk-o-Stack__item sprk-o-Stack__item--center-column@xxs"
        >
          <button
            class="sprk-c-Menu"
            type="button"
            [attr.aria-expanded]="isNarrowNavOpen ? true : false"
            (click)="toggleNarrowNav($event)"
            [attr.aria-controls]="narrowNavId"
          >
            <span class="sprk-u-ScreenReaderText">Toggle Navigation</span>
            <svg
              [ngClass]="{
                'sprk-c-Icon': true,
                'sprk-c-Icon--l': true,
                'sprk-c-Menu__icon': true,
                'sprk-c-Menu__icon--open': isNarrowNavOpen
              }"
              aria-hidden="true"
              viewBox="0 0 64 64"
              xmlns="http://www.w3.org/2000/svg"
            >
              <g>
                <path
                  class="sprk-c-Menu__line sprk-c-Menu__line--two"
                  d="m8 32h48"
                />
                <path
                  class="sprk-c-Menu__line sprk-c-Menu__line--one"
                  d="m8 18.68h48"
                />
                <path
                  class="sprk-c-Menu__line sprk-c-Menu__line--three"
                  d="m8 45.32h48"
                />
              </g>
            </svg>
          </button>
        </div>

        <div
          class="sprk-c-Masthead__branding sprk-o-Stack__item sprk-o-Stack__item--center-column@xxs"
        >
          <a sprkLink [attr.href]="logoHref" variant="unstyled">
            <ng-content select="[logo-slot]"></ng-content>
            <span class="sprk-u-ScreenReaderText">{{
              logoLinkScreenReaderText
            }}</span>
          </a>
        </div>

        <div
          class="sprk-c-Masthead__nav-item sprk-o-Stack__item sprk-o-Stack__item--center-column@xxs"
        >
          <ng-content select="[navItem-slot]"></ng-content>
        </div>
        <nav
          class="
          sprk-c-Masthead__little-nav
          sprk-o-Stack__item
          sprk-o-Stack__item--flex@xxs
          sprk-o-Stack
          sprk-o-Stack--misc-a
          sprk-o-Stack--split@xxs
          sprk-o-Stack--end-row"
          role="navigation"
        >
          <ng-content select="[little-nav-slot]"></ng-content>

          <ng-content select="[utility-slot]"></ng-content>
        </nav>
      </div>

      <div class="sprk-o-Stack__item">
        <nav
          class="sprk-c-Masthead__big-nav"
          role="navigation"
          [attr.data-id]="idString"
          *ngIf="bigNavLinks"
        >
          <ul [ngClass]="getSecondaryNavClasses()">
            <li
              *ngFor="let link of bigNavLinks"
              [ngClass]="{
                'sprk-c-Masthead__big-nav-item': true,
                'sprk-o-Stack__item': true,
                'sprk-c-Masthead__big-nav-item--open':
                  link.focused && link.subNav
              }"
              routerLinkActive="sprk-c-Masthead__big-nav-item--active"
              [attr.aria-haspopup]="link.subNav ? 'true' : null"
            >
              <div *ngIf="link.subNav">
                <sprk-dropdown
                  [choices]="link.subNav"
                  additionalTriggerClasses="sprk-b-Link--plain sprk-c-Masthead__link sprk-c-Masthead__link--big-nav"
                  additionalClasses="sprk-u-TextAlign--left"
                  triggerIconType="chevron-down"
                  [analyticsString]="link.analyticsString"
                  [triggerText]="link.text"
                ></sprk-dropdown>
              </div>
              <div *ngIf="!link.subNav">
                <a
                  sprkLink
                  variant="plain"
                  [analyticsString]="link.analyticsString"
                  class="sprk-c-Masthead__link sprk-c-Masthead__link--big-nav"
                  [attr.href]="link.href"
                >
                  {{ link.text }}
                </a>
              </div>
            </li>
          </ul>
        </nav>
      </div>

      <nav
        *ngIf="isNarrowNavOpen"
        class="sprk-c-Masthead__narrow-nav"
        role="navigation"
        [id]="narrowNavId"
      >
        <sprk-dropdown
          *ngIf="narrowSelector"
          dropdownType="mastheadSelector"
          additionalClasses="sprk-c-Masthead__selector-dropdown"
          additionalTriggerClasses="
            sprk-c-Masthead__selector
            sprk-b-Link
            sprk-b-Link--plain
            sprk-o-Stack
            sprk-o-Stack--split@xxs
            sprk-o-Stack--center-column"
          additionalTriggerTextClasses="sprk-o-Stack__item sprk-o-Stack__item--flex@xxs"
          additionalIconClasses="sprk-Stack__item sprk-u-mrs"
          [triggerText]="narrowSelector['trigger'].text"
          selector="Select One"
          triggerIconType="chevron-down"
          [choices]="narrowSelector['choices']"
        >
          <div
            *ngIf="narrowSelector['footer']"
            class="sprk-c-Dropdown__footer sprk-u-TextAlign--center"
            sprkDropdownFooter
          >
            <a
              sprkLink
              variant="unstyled"
              [analyticsString]="narrowSelector['footer'].analyticsString"
              [attr.href]="narrowSelector['footer'].href"
              class="sprk-c-Button sprk-c-Button--tertiary"
            >
              {{ narrowSelector['footer'].text }}
            </a>
          </div>
        </sprk-dropdown>

        <sprk-masthead-accordion [additionalClasses]="getNarrowNavClasses()">
          <div *ngFor="let narrowLink of narrowNavLinks">
            <div *ngIf="narrowLink.subNav">
              <sprk-masthead-accordion-item
                iconTypeOpen="chevron-down"
                iconTypeClosed="chevron-down"
                [leadingIcon]="narrowLink.leadingIcon"
                [isActive]="narrowLink.active"
                [title]="narrowLink.text"
              >
                <ul
                  class="sprk-b-List sprk-b-List--bare sprk-c-MastheadAccordion__details"
                >
                  <li
                    class="sprk-c-MastheadAccordion__item"
                    *ngFor="let subNavLink of narrowLink.subNav"
                  >
                    <a
                      sprkLink
                      variant="unstyled"
                      class="sprk-c-MastheadAccordion__summary"
                      [attr.href]="subNavLink.href"
                      [analyticsString]="subNavLink.analyticsString"
                    >
                      <sprk-icon
                        [iconType]="subNavLink.leadingIcon"
                        additionalClasses="sprk-c-Icon--stroke-current-color sprk-u-mrs"
                        *ngIf="subNavLink.leadingIcon"
                      ></sprk-icon>
                      {{ subNavLink.text }}
                    </a>
                  </li>
                </ul>
              </sprk-masthead-accordion-item>
            </div>
            <div *ngIf="!narrowLink.subNav">
              <li
                [ngClass]="{
                  'sprk-c-MastheadAccordion__item': true,
                  'sprk-c-MastheadAccordion__item--active': narrowLink.active
                }"
              >
                <a
                  sprkLink
                  variant="unstyled"
                  class="sprk-c-MastheadAccordion__summary"
                  [attr.href]="narrowLink.href"
                  [analyticsString]="narrowLink.analyticsString"
                >
                  <span class="sprk-c-MastheadAccordion__heading">
                    <sprk-icon
                      [iconType]="narrowLink.leadingIcon"
                      additionalClasses="sprk-c-Icon--stroke-current-color sprk-u-mrs"
                      *ngIf="narrowLink.leadingIcon"
                    ></sprk-icon>
                    {{ narrowLink.text }}
                  </span>
                </a>
              </li>
            </div>
          </div>
        </sprk-masthead-accordion>
        <ng-content select="[narrowNavFooter]"></ng-content>
      </nav>
    </header>
  `
    }),
    __metadata("design:paramtypes", [Renderer2, Router])
], SprkMastheadComponent);

let SprkMastheadModule = class SprkMastheadModule {
};
SprkMastheadModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            SprkIconModule,
            RouterModule,
            SprkMastheadAccordionModule,
            SprkMastheadAccordionItemModule,
            SprkDropdownModule,
            SprkAccordionModule,
            SprkAccordionItemModule,
            SprkLinkDirectiveModule,
        ],
        declarations: [SprkMastheadComponent],
        exports: [SprkMastheadComponent],
    })
], SprkMastheadModule);

let SprkModalComponent = class SprkModalComponent {
    /**
     * @ignore
     */
    constructor() {
        /**
         * The value supplied will be
         * rendered as the text for the confirm button.
         */
        this.confirmText = 'Confirm';
        /**
         * The value supplied will be rendered
         * as the text for the cancel button.
         */
        this.cancelText = 'Cancel';
        /**
         * If `true`, the Modal will be shown.
         * If `false`, the modal will not be shown.
         */
        this.isVisible = false;
        /**
         * When the Modal is closed the hide event is
         * emitted and a callback function can
         * be triggered if supplied.
         */
        this.hide = new EventEmitter();
        /**
         * Available when the Modal type is `choice`.
         * The Modal will emit a confirm click event
         * when the confirmation button is clicked.
         * A callback function can be triggered if
         * supplied.
         */
        this.confirmClick = new EventEmitter();
        /**
         * Available when the Modal type is `choice`.
         * The Modal will emit a cancel click event
         * when the cancel link is clicked.
         * A callback function can be triggered if supplied.
         */
        this.cancelClick = new EventEmitter();
        /**
         * @ignore
         */
        this.componentID = uniqueId();
        /**
         * @ignore
         */
        this.heading_id = `modalHeading__${this.componentID}`;
        /**
         * @ignore
         */
        this.content_id = `modalContent__${this.componentID}`;
    }
    /**
     * @ignore
     */
    handleKeyboardEvent(event) {
        if (this.isVisible && event.key === 'Escape') {
            this.closeModal(event);
        }
    }
    /**
     * @ignore
     */
    closeModal(event) {
        if (this.modalType !== 'wait') {
            event.preventDefault();
            this.hide.emit(event);
        }
    }
    /**
     * Emits an event when the confirmation
     * button is clicked.
     */
    emitConfirmClick(event) {
        this.confirmClick.emit(event);
    }
    /**
     * Emits an event when the cancel
     * link is clicked.
     */
    emitCancelClick(event) {
        event.preventDefault();
        this.cancelClick.emit(event);
        this.closeModal(event);
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkModalComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkModalComponent.prototype, "modalType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkModalComponent.prototype, "confirmText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkModalComponent.prototype, "cancelText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkModalComponent.prototype, "confirmAnalyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkModalComponent.prototype, "cancelAnalyticsString", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkModalComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkModalComponent.prototype, "isVisible", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], SprkModalComponent.prototype, "hide", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], SprkModalComponent.prototype, "confirmClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], SprkModalComponent.prototype, "cancelClick", void 0);
__decorate([
    HostListener('document:keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], SprkModalComponent.prototype, "handleKeyboardEvent", null);
SprkModalComponent = __decorate([
    Component({
        selector: 'sprk-modal',
        template: `
    <div
      *ngIf="isVisible"
      [ngClass]="{
        'sprk-c-Modal': true,
        'sprk-c-Modal--wait': modalType === 'wait'
      }"
      role="dialog"
      tabindex="1"
      [attr.aria-labelledby]="heading_id"
      aria-modal="true"
      [attr.aria-describedby]="content_id"
      [attr.data-id]="idString"
    >
      <div class="sprk-o-Stack sprk-o-Stack--large">
        <header class="sprk-o-Stack__item sprk-c-Modal__header">
          <h2
            class="sprk-c-Modal__heading sprk-b-TypeDisplayFour"
            [id]="heading_id"
          >
            {{ title }}
          </h2>

          <button
            *ngIf="modalType != 'wait'"
            class="sprk-c-Modal__icon"
            type="button"
            aria-label="Close Modal"
            (click)="closeModal($event)"
          >
            <sprk-icon
              iconType="close"
              additionalClasses="sprk-c-Icon--stroke-current-color"
            ></sprk-icon>
          </button>
        </header>

        <div
          class="sprk-o-Stack__item sprk-c-Modal__body sprk-o-Stack sprk-o-Stack--medium"
        >
          <div
            *ngIf="modalType == 'wait'"
            class="sprk-o-Stack__item sprk-c-Spinner sprk-c-Spinner--circle sprk-c-Spinner--large sprk-c-Spinner--dark"
          ></div>
          <ng-content></ng-content>
        </div>

        <footer
          *ngIf="modalType === 'choice'"
          class="sprk-o-Stack__item sprk-c-Modal__footer"
        >
          <button
            class="sprk-c-Button sprk-u-mrm"
            [attr.data-analytics]="confirmAnalyticsString"
            (click)="emitConfirmClick($event)"
          >
            {{ confirmText }}
          </button>

          <button
            class="sprk-c-Button sprk-c-Button--tertiary"
            [attr.data-analytics]="cancelAnalyticsString"
            (click)="emitCancelClick($event)"
          >
            {{ cancelText }}
          </button>
        </footer>
      </div>
    </div>

    <div
      *ngIf="isVisible"
      class="sprk-c-ModalMask"
      tabindex="-1"
      (click)="closeModal($event)"
    ></div>
  `
    }),
    __metadata("design:paramtypes", [])
], SprkModalComponent);

let SprkModalModule = class SprkModalModule {
};
SprkModalModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, SprkIconModule],
        declarations: [SprkModalComponent],
        exports: [SprkModalComponent]
    })
], SprkModalModule);

let SprkOrderedListComponent = class SprkOrderedListComponent {
    constructor() { }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-List'];
        switch (this.listType) {
            case 'indented':
                classArray.push('sprk-b-List--indented');
                break;
            case 'bare':
                classArray.push('sprk-b-List--bare');
                break;
            default:
                break;
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkOrderedListComponent.prototype, "listType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkOrderedListComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkOrderedListComponent.prototype, "idString", void 0);
__decorate([
    ContentChildren(SprkListItemComponent),
    __metadata("design:type", QueryList)
], SprkOrderedListComponent.prototype, "items", void 0);
SprkOrderedListComponent = __decorate([
    Component({
        selector: 'sprk-ordered-list',
        template: `
    <ol [ngClass]="getClasses()" [attr.data-id]="idString">
      <li
        *ngFor="let item of items"
        [attr.data-analytics]="item.analyticsString"
        [attr.data-id]="item.idString"
        [ngClass]="item.additionalClasses"
      >
        <ng-container [ngTemplateOutlet]="item.content"></ng-container>
      </li>
    </ol>
  `
    }),
    __metadata("design:paramtypes", [])
], SprkOrderedListComponent);

let SprkOrderedListModule = class SprkOrderedListModule {
};
SprkOrderedListModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkOrderedListComponent],
        exports: [SprkOrderedListComponent]
    })
], SprkOrderedListModule);

let SprkUnorderedListComponent = class SprkUnorderedListComponent {
    constructor() { }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [''];
        switch (this.listType) {
            case 'indented':
                classArray.push('sprk-b-List');
                classArray.push('sprk-b-List--indented');
                break;
            case 'bare':
                classArray.push('sprk-b-List');
                classArray.push('sprk-b-List--bare');
                break;
            case 'horizontal':
                classArray.push('sprk-o-HorizontalList');
                break;
            default:
                break;
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkUnorderedListComponent.prototype, "listType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkUnorderedListComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkUnorderedListComponent.prototype, "idString", void 0);
__decorate([
    ContentChildren(SprkListItemComponent),
    __metadata("design:type", QueryList)
], SprkUnorderedListComponent.prototype, "items", void 0);
SprkUnorderedListComponent = __decorate([
    Component({
        selector: 'sprk-unordered-list',
        template: `
    <ul [ngClass]="getClasses()" [attr.data-id]="idString">
      <li
        *ngFor="let item of items"
        [attr.data-analytics]="item.analyticsString"
        [attr.data-id]="item.idString"
        [ngClass]="item.additionalClasses"
      >
        <ng-container [ngTemplateOutlet]="item.content"></ng-container>
      </li>
    </ul>
  `
    }),
    __metadata("design:paramtypes", [])
], SprkUnorderedListComponent);

let SprkUnorderedListModule = class SprkUnorderedListModule {
};
SprkUnorderedListModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkUnorderedListComponent],
        exports: [SprkUnorderedListComponent]
    })
], SprkUnorderedListModule);

let SprkPaginationComponent = class SprkPaginationComponent {
    constructor() {
        /**
         * If set to `pager`, the component will render
         * in the Pager variant with no visible number
         * links. Otherwise, the component will render in
         * the Default variant if there three or fewer
         * pages or in the Long variant if there are
         * more than three pages.
         */
        this.paginationType = 'default';
        /**
         * Screen reader text for the "Next Page" icon.
         */
        this.nextLinkText = 'Next';
        /**
         * Screen reader text for the "Previous Page"
         * icon.
         */
        this.prevLinkText = 'Prev';
        /**
         * @ignore
         */
        this._currentPage = 1;
        /**
         * Accepts a function to run when the
         * previous link is clicked.
         * On click, `previousClick`
         * will emit the click event and current page.
         */
        this.previousClick = new EventEmitter();
        /**
         * Accepts a function
         * to run when the next link is clicked.
         * On click, `nextClick` will emit the click event and current page.
         */
        this.nextClick = new EventEmitter();
        /**
         * Accepts a function to run when the individual page
         * links are clicked. On click, `pageClick` will
         * emit the click event and current page.
         */
        this.pageClick = new EventEmitter();
    }
    /**
     * The current page number.
     * In the Default and Long variants,
     * this value corresponds to the active page link.
     */
    set currentPage(value) {
        if (value > this.totalPages()) {
            value = this.totalPages();
        }
        else if (value < 1) {
            value = 1;
        }
        this._currentPage = value;
    }
    get currentPage() {
        return this._currentPage;
    }
    /**
     * @ignore
     */
    goToPage(event, page) {
        event.preventDefault();
        this.currentPage = page;
        this.pageClick.emit({ event, page });
    }
    /**
     * @ignore
     */
    goBack(event, page) {
        event.preventDefault();
        let newPage = page;
        if (this.currentPage > 1) {
            newPage = this.currentPage - 1;
            this.currentPage = newPage;
        }
        // Page is still returning the old page. This allows us to
        // close Issue 1401 without introducing a breaking change.
        this.previousClick.emit({ event, page, newPage });
    }
    /**
     * @ignore
     */
    goForward(event, page) {
        event.preventDefault();
        let newPage = page;
        if (this.currentPage < this.totalPages()) {
            newPage = this.currentPage + 1;
            this.currentPage = newPage;
        }
        // Page is still returning the old page. This allows us to
        // close Issue 1401 without introducing a breaking change.
        this.nextClick.emit({ event, page, newPage });
    }
    /**
     * @ignore
     * @returns total number of pages based on total
     * number of items and the desired number of
     * items to show per page.
     */
    totalPages() {
        return Math.ceil(this.totalItems / this.itemsPerPage);
    }
    /**
     * @ignore
     * @returns true if currently on the last page.
     */
    isLastPage() {
        return this.currentPage === this.totalPages();
    }
    /**
     * @ignore
     * @returns true if the component is in
     * either the default or long variant.
     */
    showNumbers() {
        return this.paginationType !== 'pager';
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [''];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkPaginationComponent.prototype, "paginationType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SprkPaginationComponent.prototype, "totalItems", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SprkPaginationComponent.prototype, "itemsPerPage", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPaginationComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkPaginationComponent.prototype, "nextLinkText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkPaginationComponent.prototype, "prevLinkText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPaginationComponent.prototype, "analyticsStringFirstLink", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPaginationComponent.prototype, "analyticsStringSecondLink", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPaginationComponent.prototype, "analyticsStringThirdLink", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPaginationComponent.prototype, "analyticsStringLinkNext", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPaginationComponent.prototype, "analyticsStringLinkPrev", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPaginationComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SprkPaginationComponent.prototype, "currentPage", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], SprkPaginationComponent.prototype, "previousClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], SprkPaginationComponent.prototype, "nextClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], SprkPaginationComponent.prototype, "pageClick", void 0);
SprkPaginationComponent = __decorate([
    Component({
        selector: 'sprk-pagination',
        template: `
    <nav
      aria-label="Pagination Navigation"
      [ngClass]="getClasses()"
      [attr.data-id]="idString"
    >
      <sprk-unordered-list
        listType="horizontal"
        additionalClasses="sprk-c-Pagination sprk-o-HorizontalList--spacing-medium"
      >
        <sprk-list-item>
          <a
            sprkLink
            variant="plain"
            (click)="goBack($event, currentPage)"
            [isDisabled]="currentPage === 1"
            class="sprk-c-Pagination__icon"
            [analyticsString]="analyticsStringLinkPrev"
            aria-label="Previous Page"
            href="#"
          >
            <span class="sprk-u-ScreenReaderText">{{ prevLinkText }}</span>
            <sprk-icon
              additionalClasses="sprk-c-Icon--stroke-current-color"
              iconType="chevron-left"
            ></sprk-icon>
          </a>
        </sprk-list-item>

        <sprk-list-item *ngIf="showNumbers()">
          <a
            sprkLink
            href="#"
            (click)="goToPage($event, 1)"
            [ngClass]="{
              'sprk-c-Pagination__link': true,
              'sprk-c-Pagination__link--current': currentPage === 1
            }"
            [analyticsString]="analyticsStringFirstLink"
            [attr.aria-current]="currentPage === 1"
            aria-label="Page 1"
          >
            1
          </a>
        </sprk-list-item>

        <sprk-list-item
          *ngIf="showNumbers() && currentPage !== 2 && totalPages() === 3"
        >
          <a
            sprkLink
            href="#"
            (click)="goToPage($event, 2)"
            class="sprk-c-Pagination__link"
            [attr.aria-current]="false"
            aria-label="Page 2"
          >
            2
          </a>
        </sprk-list-item>

        <sprk-list-item
          *ngIf="showNumbers() && currentPage > 2 && totalPages() > 3"
        >
          ...
        </sprk-list-item>

        <sprk-list-item
          *ngIf="showNumbers() && currentPage > 1 && currentPage < totalPages()"
        >
          <a
            sprkLink
            href="#"
            (click)="goToPage($event, currentPage)"
            class="sprk-c-Pagination__link sprk-c-Pagination__link--current"
            aria-current="true"
            [analyticsString]="analyticsStringSecondLink"
            attr.aria-label="Page {{ currentPage }}"
          >
            {{ currentPage }}
          </a>
        </sprk-list-item>

        <sprk-list-item
          *ngIf="
            showNumbers() && currentPage < totalPages() - 1 && totalPages() > 3
          "
        >
          ...
        </sprk-list-item>

        <sprk-list-item *ngIf="showNumbers() && totalPages() > 1">
          <a
            sprkLink
            href="#"
            (click)="goToPage($event, totalPages())"
            [ngClass]="{
              'sprk-c-Pagination__link': true,
              'sprk-c-Pagination__link--current': currentPage === totalPages()
            }"
            attr.aria-label="Page {{ totalPages() }}"
            [analyticsString]="analyticsStringThirdLink"
            [attr.aria-current]="currentPage === totalPages()"
          >
            {{ totalPages() }}
          </a>
        </sprk-list-item>

        <sprk-list-item>
          <a
            sprkLink
            href="#"
            variant="plain"
            [isDisabled]="isLastPage()"
            (click)="goForward($event, currentPage)"
            class="sprk-c-Pagination__icon"
            [analyticsString]="analyticsStringLinkNext"
            aria-label="Next Page"
          >
            <span class="sprk-u-ScreenReaderText">{{ nextLinkText }}</span>
            <sprk-icon
              additionalClasses="sprk-c-Icon--stroke-current-color"
              iconType="chevron-right"
            ></sprk-icon>
          </a>
        </sprk-list-item>
      </sprk-unordered-list>
    </nav>
  `
    }),
    __metadata("design:paramtypes", [])
], SprkPaginationComponent);

let SprkPaginationModule = class SprkPaginationModule {
};
SprkPaginationModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            SprkUnorderedListModule,
            SprkIconModule,
            SprkLinkDirectiveModule,
            SprkListItemModule
        ],
        declarations: [SprkPaginationComponent],
        exports: [SprkPaginationComponent]
    })
], SprkPaginationModule);

let SprkPromoComponent = class SprkPromoComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-c-Promo',
            'sprk-o-Stack',
            'sprk-o-Stack--split@s'
        ];
        if (this.isFlag) {
            classArray.push('sprk-c-Promo--flag');
        }
        if (this.hasBorder) {
            classArray.push('sprk-c-Promo--bordered');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getClassesFlag() {
        const classArray = [
            'sprk-o-Stack__item--fourth@s',
            'sprk-o-Stack__item'
        ];
        if (this.additionalClassesFlagLink) {
            this.additionalClassesFlagLink.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getClassesImg() {
        const classArray = [
            'sprk-o-Stack__item',
            'sprk-o-Stack__item--half@s'
        ];
        if (this.additionalClassesImgLink) {
            this.additionalClassesImgLink.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getClassesContent() {
        const classArray = [
            'sprk-c-Promo__content',
            'sprk-o-Stack__item',
            'sprk-o-Stack',
            'sprk-o-Stack--large'
        ];
        if (this.isFlag) {
            classArray.push('sprk-o-Stack__item--three-fourths@s');
        }
        else {
            if (this.imgSrc) {
                classArray.push('sprk-o-Stack__item--half@s');
            }
        }
        if (this.additionalClassesContent) {
            this.additionalClassesContent.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "subtitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "cta", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "ctaText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "buttonHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "buttonLinkAnalytics", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "ctaLinkHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "ctaLinkAnalytics", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "additionalClassesContent", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkPromoComponent.prototype, "isFlag", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "additionalClassesFlagLink", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "flagLinkAnalytics", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "imgSrc", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "imgAlt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "imgHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "imgLinkAnalytics", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "additionalClassesImgLink", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkPromoComponent.prototype, "mediaRev", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SprkPromoComponent.prototype, "hasBorder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkPromoComponent.prototype, "idString", void 0);
SprkPromoComponent = __decorate([
    Component({
        selector: 'sprk-promo',
        template: `
    <div [ngClass]="getClasses()" [attr.data-id]="idString">
      <a
        sprkLink
        variant="unstyled"
        *ngIf="isFlag && !mediaRev"
        [ngClass]="getClassesFlag()"
        [attr.href]="imgHref"
        [analyticsString]="flagLinkAnalytics"
      >
        <img
          class="sprk-c-Promo__image--flag"
          alt="{{ imgAlt }}"
          src="{{ imgSrc }}"
        />
      </a>
      <a
        sprkLink
        variant="unstyled"
        *ngIf="imgSrc && !mediaRev && !isFlag"
        [attr.href]="imgHref"
        [analyticsString]="imgLinkAnalytics"
        [ngClass]="getClassesImg()"
      >
        <img
          class="sprk-c-Promo__image"
          alt="{{ imgAlt }}"
          src="{{ imgSrc }}"
        />
      </a>

      <div [ngClass]="getClassesContent()">
        <h3
          *ngIf="title"
          class="sprk-b-TypeDisplayFive sprk-o-Stack__item sprk-c-Promo__title"
        >
          {{ title }}
        </h3>

        <div *ngIf="subtitle" class="sprk-c-Promo__subtitle sprk-o-Stack__item">
          {{ subtitle }}
        </div>

        <div class="sprk-b-TypeBodyTwo sprk-o-Stack__item">
          <ng-content></ng-content>
        </div>

        <div *ngIf="cta === 'button'" class="sprk-o-Stack__item">
          <a
            sprkLink
            variant="unstyled"
            [attr.href]="buttonHref"
            class="sprk-c-Button"
            [analyticsString]="buttonLinkAnalytics"
          >
            {{ ctaText }}
          </a>
        </div>

        <a
          sprkLink
          variant="simple"
          *ngIf="cta === 'link'"
          [attr.href]="ctaLinkHref"
          class="sprk-o-Stack__item"
          [analyticsString]="ctaLinkAnalytics"
        >
          {{ ctaText }}
        </a>
      </div>

      <a
        sprkLink
        variant="unstyled"
        *ngIf="isFlag && mediaRev"
        [attr.href]="imgHref"
        [ngClass]="getClassesFlag()"
        [analyticsString]="flagLinkAnalytics"
      >
        <img
          class="sprk-c-Promo__image--flag"
          alt="{{ imgAlt }}"
          src="{{ imgSrc }}"
        />
      </a>

      <a
        sprkLink
        variant="unstyled"
        *ngIf="imgSrc && mediaRev && !isFlag"
        [attr.href]="imgHref"
        [analyticsString]="imgLinkAnalytics"
        [ngClass]="getClassesImg()"
      >
        <img
          class="sprk-c-Promo__image"
          alt="{{ imgAlt }}"
          src="{{ imgSrc }}"
        />
      </a>
    </div>
  `
    })
], SprkPromoComponent);

let SprkPromoModule = class SprkPromoModule {
};
SprkPromoModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            SprkIconModule,
            SprkLinkDirectiveModule
        ],
        declarations: [SprkPromoComponent],
        exports: [SprkPromoComponent]
    })
], SprkPromoModule);

let SprkTabbedNavigationComponent = class SprkTabbedNavigationComponent {
    /**
     * @ignore
     */
    constructor(ref) {
        this.ref = ref;
        /**
         * @ignore
         */
        this.componentID = uniqueId();
        /**
         * @ignore
         */
        this.activeClass = 'sprk-c-Tabs__button--active';
        this.ariaOrientation(window.innerWidth, this.ref.nativeElement);
    }
    /**
     * @ignore
     */
    onClick($event) {
        if ($event.target.classList.contains('sprk-c-Tabs__button')) {
            const activePanel = this.panels.find(panel => {
                return (panel.ref.nativeElement.id ===
                    $event.target.getAttribute('aria-controls'));
            });
            this.resetTabs(this.tabs.map(tab => tab.ref.nativeElement), this.panels.map(panel => panel.ref.nativeElement), this.activeClass);
            this.setActiveTab($event.target, activePanel.ref.nativeElement, this.activeClass);
        }
    }
    /**
     * @ignore
     */
    onResize() {
        this.ariaOrientation(window.innerWidth, this.ref.nativeElement);
    }
    /**
     * @ignore
     */
    onKeydown($event) {
        const isTabsButton = $event.target.classList.contains('sprk-c-Tabs__button');
        if (!isTabsButton) {
            return;
        }
        const keys = {
            end: 35,
            home: 36,
            left: 37,
            up: 38,
            right: 39,
            down: 40,
            tab: 9
        };
        const tabElements = this.tabs.map(tab => tab.ref.nativeElement);
        const panelElements = this.panels.map(panel => panel.ref.nativeElement);
        if ($event.keyCode === keys.left || $event.keyCode === keys.up) {
            this.incrementTab(tabElements, panelElements, this.activeClass, -1);
        }
        else if ($event.keyCode === keys.right || $event.keyCode === keys.down) {
            this.incrementTab(tabElements, panelElements, this.activeClass, 1);
        }
        else if ($event.keyCode === keys.tab) {
            if ($event.target.getAttribute('role') === 'tab') {
                $event.preventDefault();
                panelElements[this.getActiveTabIndex(tabElements, this.activeClass)].focus();
            }
        }
        else if ($event.keyCode === keys.home) {
            this.goToEndTab(tabElements, panelElements, this.activeClass, -1);
        }
        else if ($event.keyCode === keys.end) {
            this.goToEndTab(tabElements, panelElements, this.activeClass, 1);
        }
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Tabs'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    ngAfterContentInit() {
        let tabIDs = [];
        let panelIDs = [];
        if (this.tabs && this.panels) {
            this.tabs.forEach((tab, index) => {
                const tabID = `tabbed-navigation-${this.componentID}-tab-${index}`;
                const panelID = `tabbed-navigation-${this.componentID}-panel-${index}`;
                tab.ref.nativeElement.setAttribute('id', tabID);
                tab.ref.nativeElement.setAttribute('aria-controls', panelID);
                tabIDs.push(tabID);
                panelIDs.push(panelID);
            });
            tabIDs = tabIDs.reverse();
            panelIDs = panelIDs.reverse();
            this.panels.forEach(panel => {
                panel.ref.nativeElement.setAttribute('id', panelIDs.pop());
                panel.ref.nativeElement.setAttribute('aria-labelledby', tabIDs.pop());
            });
        }
    }
    /**
     * @ignore
     */
    ariaOrientation(width, element) {
        // switch aria-orientation on mobile (based on _tabs.scss breakpoint)
        if (width <= 736) {
            element.setAttribute('aria-orientation', 'vertical');
        }
        else {
            element.setAttribute('aria-orientation', 'horizontal');
        }
    }
    /**
     * @ignore
     */
    getActiveTabIndex(tabs, activeClass) {
        let activeIndex = null;
        tabs.forEach((tab, index) => {
            if (tab.classList.contains(activeClass || 'sprk-c-Tabs__button--active')) {
                activeIndex = index;
            }
        });
        return activeIndex;
    }
    /**
     * @ignore
     */
    resetTabs(tabs, tabpanels, activeClass) {
        tabs.forEach(tab => {
            tab.classList.remove(activeClass || 'sprk-c-Tabs__button--active');
            tab.removeAttribute('tabindex');
            tab.setAttribute('aria-selected', 'false');
            tabpanels.forEach(panel => {
                panel.classList.add('sprk-u-HideWhenJs');
            });
        });
    }
    /**
     * @ignore
     */
    incrementTab(tabs, tabpanels, activeClass, direction) {
        let activeIndex = this.getActiveTabIndex(tabs, activeClass);
        let foundNewIndex = false;
        // Start looking for the next available tab
        while (foundNewIndex === false) {
            // if the next tab would be off the left of the tabstrip
            if (activeIndex + direction < 0) {
                // loop to the end and keep looking
                activeIndex = tabs.length;
                // if the next tab would be off the right of the tabstrip
            }
            else if (activeIndex + direction >= tabs.length) {
                // loop back to the beginning and keep looking
                activeIndex = -1;
                // If the next tab is not disabled
            }
            else if (!tabs[activeIndex + direction].hasAttribute('disabled')) {
                // move to the next tab
                activeIndex += direction;
                // stop looking for the correct tab
                foundNewIndex = true;
            }
            else {
                // move to the next tab and keep looking
                activeIndex += direction;
            }
        }
        // deselect all tabs
        this.resetTabs(tabs, tabpanels, activeClass);
        // select the correct tab
        this.setActiveTab(tabs[activeIndex], tabpanels[activeIndex], activeClass);
    }
    goToEndTab(tabs, tabpanels, activeClass, direction) {
        let newActiveIndex;
        // if direction is positive, go to the right-most tab
        if (direction > 0) {
            newActiveIndex = tabs.length - 1;
            // else go to the left-most tab
        }
        else {
            newActiveIndex = 0;
        }
        let foundNewIndex = false;
        // step through the tabs until we find one that isn't disabled
        while (foundNewIndex === false) {
            // if this tab is not disabled
            if (!tabs[newActiveIndex].hasAttribute('disabled')) {
                // stop looking for the correct tab
                foundNewIndex = true;
                // else step one tab away from the end and keep looking
            }
            else {
                newActiveIndex -= direction;
            }
        }
        this.resetTabs(tabs, tabpanels, activeClass);
        this.setActiveTab(tabs[newActiveIndex], tabpanels[newActiveIndex], activeClass);
    }
    /**
     * @ignore
     */
    setActiveTab(tab, tabpanel, activeClass) {
        tab.classList.add(activeClass || 'sprk-c-Tabs__button--active');
        tab.setAttribute('tabindex', '0');
        tab.setAttribute('aria-selected', 'true');
        if (tabpanel) {
            tabpanel.classList.remove('sprk-u-HideWhenJs');
        }
        tab.focus();
    }
};
SprkTabbedNavigationComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTabbedNavigationComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTabbedNavigationComponent.prototype, "idString", void 0);
__decorate([
    ContentChildren(SprkTabbedNavigationTabDirective),
    __metadata("design:type", QueryList)
], SprkTabbedNavigationComponent.prototype, "tabs", void 0);
__decorate([
    ContentChildren(SprkTabbedNavigationPanelDirective),
    __metadata("design:type", QueryList)
], SprkTabbedNavigationComponent.prototype, "panels", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkTabbedNavigationComponent.prototype, "onClick", null);
__decorate([
    HostListener('window:resize'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SprkTabbedNavigationComponent.prototype, "onResize", null);
__decorate([
    HostListener('keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SprkTabbedNavigationComponent.prototype, "onKeydown", null);
SprkTabbedNavigationComponent = __decorate([
    Component({
        selector: 'sprk-tabbed-navigation',
        template: `
    <div [ngClass]="getClasses()" [attr.data-id]="idString">
      <div class="sprk-c-Tabs__buttons" role="tablist">
        <ng-content select="[sprkTabbedNavigationTab]"></ng-content>
      </div>
      <ng-content select="[sprkTabbedNavigationPane]"></ng-content>
      <ng-content></ng-content>
    </div>
  `
    }),
    __metadata("design:paramtypes", [ElementRef])
], SprkTabbedNavigationComponent);

let SprkTabbedNavigationModule = class SprkTabbedNavigationModule {
};
SprkTabbedNavigationModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkTabbedNavigationComponent],
        exports: [SprkTabbedNavigationComponent]
    })
], SprkTabbedNavigationModule);

let SprkTableComponent = class SprkTableComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-b-TableContainer'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getTableClasses() {
        const classArray = [
            'sprk-b-Table',
            'sprk-b-Table--spacing-medium',
        ];
        if (this.additionalTableClasses) {
            this.additionalTableClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTableComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTableComponent.prototype, "additionalTableClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTableComponent.prototype, "idString", void 0);
SprkTableComponent = __decorate([
    Component({
        selector: 'sprk-table',
        template: `
    <div [ngClass]="getClasses()" [attr.data-id]="idString">
      <table [ngClass]="getTableClasses()">
        <ng-content></ng-content>
      </table>
    </div>
  `
    })
], SprkTableComponent);

let SprkTableModule = class SprkTableModule {
};
SprkTableModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkTableComponent],
        exports: [SprkTableComponent]
    })
], SprkTableModule);

let SprkButtonDirective = class SprkButtonDirective {
    /**
     * @ignore
     */
    constructor(ref, renderer) {
        this.ref = ref;
        this.renderer = renderer;
        /**
         * Will show a spinner inside the
         * button if set to `true`.
         */
        this.isSpinning = false;
        /**
         * Optional string value that is
         * set for the `aria-label`
         * when `isSpinning` is `true`.
         */
        this.spinningAriaLabel = 'Loading';
        /**
         *  Determines the coresponding button style.
         */
        this.variant = 'primary';
        /**
         * @ignore
         */
        this.setSpinning = (element) => {
            const el = element;
            const width = element.offsetWidth;
            const ariaLabel = this.spinningAriaLabel;
            let spinnerClass = 'sprk-c-Spinner sprk-c-Spinner--circle';
            if (el.classList.contains('sprk-c-Button--secondary') ||
                this.variant === 'secondary') {
                spinnerClass += ' sprk-c-Spinner--dark';
            }
            this.renderer.setAttribute(el, 'data-sprk-spinner-text', el.textContent);
            this.renderer.setAttribute(el, 'aria-label', ariaLabel);
            el.innerHTML = `<div class="${spinnerClass}"></div>`;
            el.setAttribute('data-sprk-has-spinner', 'true');
            this.renderer.setAttribute(el, 'data-sprk-has-spinner', 'true');
            this.renderer.setAttribute(el, 'style', `width: ${width}px`);
        };
    }
    ngOnInit() {
        if (this.variant === 'secondary') {
            this.renderer.addClass(this.ref.nativeElement, 'sprk-c-Button--secondary');
        }
        if (this.variant === 'tertiary') {
            this.renderer.addClass(this.ref.nativeElement, 'sprk-c-Button--tertiary');
        }
    }
    /**
     * Add spinner only after view has loaded.
     * This is to allow time for the text
     * content of the button to load so that
     * the width value accounts for that text.
     */
    ngAfterViewInit() {
        if (this.isSpinning) {
            this.setSpinning(this.ref.nativeElement);
        }
    }
    ngOnChanges(changes) {
        if (this.isSpinning && !changes['isSpinning'].isFirstChange()) {
            this.setSpinning(this.ref.nativeElement);
        }
    }
};
SprkButtonDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkButtonDirective.prototype, "isSpinning", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkButtonDirective.prototype, "spinningAriaLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkButtonDirective.prototype, "variant", void 0);
__decorate([
    HostBinding('class.sprk-c-Button'),
    __metadata("design:type", Object)
], SprkButtonDirective.prototype, "true", void 0);
__decorate([
    HostBinding('attr.data-id'),
    Input(),
    __metadata("design:type", String)
], SprkButtonDirective.prototype, "idString", void 0);
__decorate([
    HostBinding('attr.data-analytics'),
    Input(),
    __metadata("design:type", String)
], SprkButtonDirective.prototype, "analyticsString", void 0);
SprkButtonDirective = __decorate([
    Directive({
        selector: '[sprkButton]'
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], SprkButtonDirective);

let SprkButtonModule = class SprkButtonModule {
};
SprkButtonModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        declarations: [SprkButtonDirective],
        exports: [SprkButtonDirective]
    })
], SprkButtonModule);

let SprkAwardComponent = class SprkAwardComponent {
    /**
     * @ignore
     */
    getClasses() {
        const classArray = [
            'sprk-o-Stack sprk-o-Stack--medium sprk-o-Stack__item sprk-o-Stack__item--center-column'
        ];
        // Handle the choice of item split
        // breakpoint by adding CSS class
        switch (this.splitAt) {
            case 'tiny':
                classArray.push('sprk-o-Stack--split@xs');
                break;
            case 'small':
                classArray.push('sprk-o-Stack--split@s');
                break;
            case 'medium':
                classArray.push('sprk-o-Stack--split@m');
                break;
            case 'large':
                classArray.push('sprk-o-Stack--split@l');
                break;
            case 'huge':
                classArray.push('sprk-o-Stack--split@xl');
                break;
            default:
                break;
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getImgContainerClasses() {
        const classArray = [
            'sprk-o-Stack__item'
        ];
        // Handle the choice of item split
        // breakpoint by adding CSS class
        switch (this.splitAt) {
            case 'tiny':
                classArray.push('sprk-o-Stack__item--flex@xs');
                break;
            case 'small':
                classArray.push('sprk-o-Stack__item--flex@s');
                break;
            case 'medium':
                classArray.push('sprk-o-Stack__item--flex@m');
                break;
            case 'large':
                classArray.push('sprk-o-Stack__item--flex@l');
                break;
            case 'huge':
                classArray.push('sprk-o-Stack__item--flex@xl');
                break;
            default:
                break;
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getClassesImgOne() {
        const classArray = [
            'sprk-o-Stack__item sprk-o-Stack__item--center-column'
        ];
        if (this.additionalClassesImgOne) {
            this.additionalClassesImgOne.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getClassesImgTwo() {
        const classArray = [
            'sprk-o-Stack__item sprk-o-Stack__item--center-column'
        ];
        if (this.additionalClassesImgTwo) {
            this.additionalClassesImgTwo.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "splitAt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "imgOneAlt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "imgOneHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "imgTwoHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "imgTwoAlt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "imgOneSrc", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "imgTwoSrc", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "analyticsStringImgOne", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "analyticsStringImgTwo", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "analyticsStringDisclaimer", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "additionalClassesImgOne", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "additionalClassesImgTwo", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "disclaimerTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "disclaimerCopy", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "disclaimer", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkAwardComponent.prototype, "idString", void 0);
SprkAwardComponent = __decorate([
    Component({
        selector: 'sprk-award',
        template: `
    <sprk-stack
      itemSpacing="medium"
      additionalClasses="{{ additionalClasses }}"
    >
      <h2
        sprkStackItem
        [attr.data-id]="idString"
        class="
          sprk-o-Stack__item
          sprk-b-TypeDisplayFive
          sprk-b-Measure sprk-b-Measure--narrow
          sprk-u-TextAlign--center
          sprk-o-Stack__item--center-column
        "
      >
        {{ title }}
      </h2>

      <div sprkStackItem [ngClass]="getClasses()">
        <div
          [ngClass]="getImgContainerClasses()"
        >
          <a
            sprkLink
            variant="unstyled"
            class="sprk-o-Stack"
            [attr.href]="imgOneHref"
            [analyticsString]="analyticsStringImgOne"
          >
            <img
              [ngClass]="getClassesImgOne()"
              alt="{{ imgOneAlt }}"
              src="{{ imgOneSrc }}"
            />
          </a>
        </div>
        <div
          [ngClass]="getImgContainerClasses()"
        >
          <a
            sprkLink
            variant="unstyled"
            class="sprk-o-Stack"
            [attr.href]="imgTwoHref"
            [analyticsString]="analyticsStringImgTwo"
          >
            <img
              [ngClass]="getClassesImgTwo()"
              alt="{{ imgTwoAlt }}"
              src="{{ imgTwoSrc }}"
            />
          </a>
        </div>
      </div>

      <sprk-toggle
        *ngIf="disclaimer !== 'false'"
        sprkStackItem
        additionalClasses="sprk-o-Stack__item--start-column"
        toggleType="base"
        title="{{ disclaimerTitle }}"
        analyticsString="{{ analyticsStringDisclaimer }}"
      >
        <p class="sprk-b-TypeBodyFour">{{ disclaimerCopy }}</p>
      </sprk-toggle>
    </sprk-stack>
  `
    })
], SprkAwardComponent);

let SprkAwardModule = class SprkAwardModule {
};
SprkAwardModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            SprkStackModule,
            SprkStackItemModule,
            SprkLinkDirectiveModule,
            SprkToggleModule
        ],
        declarations: [SprkAwardComponent],
        exports: [SprkAwardComponent]
    })
], SprkAwardModule);

let SprkCardComponent = class SprkCardComponent {
    constructor() {
        /**
         * The type of Card variant to render.
         * The available values are `base`, `teaser`, and `teaserHeading`.
         */
        this.cardType = 'base';
        /**
         * Determines which type of call to action is rendered.
         * The available values are `link` and `button`.
         */
        this.ctaType = 'link';
    }
    /**
     * @ignore
     */
    getClassesCta() {
        const ctaClassArray = [];
        if (this.ctaType === 'button') {
            ctaClassArray.push('sprk-c-Button');
        }
        else {
            ctaClassArray.push('sprk-b-Link');
            if (this.ctaIcon) {
                ctaClassArray.push('sprk-b-Link--simple');
                ctaClassArray.push('sprk-b-Link--has-icon');
            }
        }
        if (this.additionalCtaClasses) {
            this.additionalCtaClasses.split(' ').forEach(className => {
                ctaClassArray.push(className);
            });
        }
        return ctaClassArray.join(' ');
    }
    /**
     * @ignore
     */
    getClassesCard() {
        const classArray = ['sprk-c-Card', 'sprk-o-Stack'];
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "cardType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "body", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "media", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "additionalClassesIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "imgSrc", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "imgAlt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "iconType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "iconHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "imgHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "ctaIcon", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "ctaType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "ctaText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "ctaAnalytics", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "imgLinkAnalytics", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "iconLinkAnalytics", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "ctaHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "additionalCtaClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkCardComponent.prototype, "idString", void 0);
SprkCardComponent = __decorate([
    Component({
        selector: 'sprk-card',
        template: `
    <div
      [ngClass]="getClassesCard()"
      *ngIf="cardType === 'teaser'"
      [attr.data-id]="idString"
    >
      <a
        sprkLink
        variant="unstyled"
        *ngIf="media === 'img'"
        [href]="imgHref"
        class="sprk-o-Stack__item"
        [analyticsString]="imgLinkAnalytics"
      >
        <img
          class="sprk-c-Card__media"
          [attr.alt]="imgAlt"
          [attr.src]="imgSrc"
        />
      </a>

      <div
        [ngClass]="{
          'sprk-o-Stack__item': true,
          'sprk-c-Card__content': true,
          'sprk-o-Stack': true,
          'sprk-o-Stack--medium': true,
          'sprk-u-TextAlign--center': media === 'icon'
        }"
      >
        <a
          sprkLink
          variant="unstyled"
          *ngIf="media === 'icon'"
          [attr.href]="iconHref"
          class="sprk-o-Stack__item sprk-u-AbsoluteCenter"
          [analyticsString]="iconLinkAnalytics"
        >
          <sprk-icon
            [iconType]="iconType"
            [additionalClasses]="additionalClassesIcon"
          ></sprk-icon>
        </a>

        <h3 class="sprk-b-TypeDisplayFive sprk-o-Stack__item">{{ title }}</h3>

        <p class="sprk-b-TypeBodyTwo sprk-o-Stack__item">{{ body }}</p>

        <div class="sprk-o-Stack__item">
          <a
            sprkLink
            variant="unstyled"
            [attr.href]="ctaHref"
            [ngClass]="getClassesCta()"
            [analyticsString]="ctaAnalytics"
          >
            {{ ctaText }}
            <sprk-icon
              *ngIf="ctaIcon && (ctaType === 'link')"
              [iconType]="ctaIcon"
            ></sprk-icon>
          </a>
        </div>
      </div>
    </div>

    <div
      [ngClass]="getClassesCard()"
      *ngIf="cardType === 'base'"
      [attr.data-id]="idString"
    >
      <ng-content></ng-content>
    </div>

    <div
      [ngClass]="getClassesCard()"
      *ngIf="cardType === 'teaserHeading'"
      [attr.data-id]="idString"
    >
      <h3
        class="sprk-o-Stack__item sprk-c-Card__content sprk-b-TypeDisplayFive"
      >
        {{ title }}
      </h3>

      <div
        class="sprk-o-Stack__item sprk-c-Card__content sprk-o-Stack sprk-o-Stack--medium"
      >
        <a
          sprkLink
          variant="unstyled"
          *ngIf="media === 'img'"
          [attr.href]="imgHref"
          class="sprk-o-Stack__item"
          [analyticsString]="imgLinkAnalytics"
        >
          <img [attr.alt]="imgAlt" [attr.src]="imgSrc" />
        </a>

        <a
          sprkLink
          *ngIf="media === 'icon'"
          [attr.href]="iconHref"
          variant="unstyled"
          class="sprk-o-Stack__item sprk-o-Stack__item--center"
          [analyticsString]="iconLinkAnalytics"
        >
          <sprk-icon
            [iconType]="iconType"
            [additionalClasses]="additionalClassesIcon"
          ></sprk-icon>
        </a>

        <p class="sprk-b-TypeBodyTwo sprk-o-Stack__item">{{ body }}</p>

        <div class="sprk-o-Stack__item">
          <a
            sprkLink
            variant="unstyled"
            [attr.href]="ctaHref"
            [ngClass]="getClassesCta()"
            [analyticsString]="ctaAnalytics"
          >
            {{ ctaText }}
            <sprk-icon
              *ngIf="ctaIcon && (ctaType === 'link')"
              [iconType]="ctaIcon"
            ></sprk-icon>
          </a>
        </div>
      </div>
    </div>
  `
    })
], SprkCardComponent);

let SprkCardModule = class SprkCardModule {
};
SprkCardModule = __decorate([
    NgModule({
        imports: [CommonModule, SprkIconModule, SprkLinkDirectiveModule],
        declarations: [SprkCardComponent],
        exports: [SprkCardComponent]
    })
], SprkCardModule);

let SprkDictionaryComponent = class SprkDictionaryComponent {
    constructor() {
        /**
         * The collection of key-value pairs to be rendered
         * into the component.
         */
        this.data = {};
        /**
         * Determines the variant of the dictionary component to render.
         * The only available option is `striped`.
         * Supplying no value will cause the base variant to be used.
         */
        this.dictionaryType = 'base';
        /**
         * @ignore
         * Used to grab all the keys from
         * objects.
         */
        this.objectKeys = Object.keys;
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-Dictionary'];
        if (this.dictionaryType === 'striped') {
            classArray.push('sprk-c-Dictionary--striped');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkDictionaryComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkDictionaryComponent.prototype, "dictionaryType", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDictionaryComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkDictionaryComponent.prototype, "idString", void 0);
SprkDictionaryComponent = __decorate([
    Component({
        selector: 'sprk-dictionary',
        template: `
    <div [ngClass]="getClasses()" [attr.data-id]="idString">
      <dl class="sprk-c-Dictionary__keyvaluepairs">
        <div
          *ngFor="let key of objectKeys(data)"
          class="sprk-c-Dictionary__keyvaluepair"
        >
          <dt
            class="sprk-c-Dictionary__key sprk-b-Label sprk-b-Label--no-input"
          >
            {{ key }}
          </dt>
          <dd class="sprk-c-Dictionary__value">{{ data[key] }}</dd>
        </div>
      </dl>
    </div>
  `
    })
], SprkDictionaryComponent);

let SprkDictionaryModule = class SprkDictionaryModule {
};
SprkDictionaryModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [SprkDictionaryComponent],
        exports: [SprkDictionaryComponent]
    })
], SprkDictionaryModule);

let SprkHighlightBoardComponent = class SprkHighlightBoardComponent {
    constructor() {
        /**
         * @ignore
         */
        this.centerBtns = '';
    }
    ngOnInit() {
        if (!this.ctaText && this.ctaText2) {
            console.warn(`
        Spark Design System Warning - <sprk-highlight-board> Component:
        A secondary call-to-action (CTA)
        should not exist without a primary CTA.
        If there is only one CTA, it must be set on
        ctaText and ctaHref.
      `);
        }
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-c-HighlightBoard'];
        switch (this.type) {
            case 'noImage':
                this.centerBtns = 'sprk-o-Stack--center-row';
                break;
            case 'stacked':
                this.centerBtns = 'sprk-o-Stack--center-row';
                classArray.push('sprk-c-HighlightBoard--has-image sprk-c-HighlightBoard--stacked');
                break;
            default:
                classArray.push('sprk-c-HighlightBoard--has-image');
                break;
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "heading", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "imgSrc", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "imgAlt", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "ctaText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "ctaHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "ctaText2", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "ctaHref2", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "analyticsStringCta", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "analyticsStringCta2", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHighlightBoardComponent.prototype, "idString", void 0);
SprkHighlightBoardComponent = __decorate([
    Component({
        selector: 'sprk-highlight-board',
        template: `
    <div [ngClass]="getClasses()" [attr.data-id]="idString">
      <img
        *ngIf="type !== 'noImage'"
        class="sprk-c-HighlightBoard__image"
        src="{{ imgSrc }}"
        alt="{{ imgAlt }}"
      />

      <sprk-stack
        sprkStackItem
        itemSpacing="large"
        additionalClasses="sprk-c-HighlightBoard__content"
      >
        <h1
          sprkStackItem
          [ngClass]="{
            'sprk-b-TypeDisplayTwo': type === 'noImage',
            'sprk-b-TypeDisplayOne': type !== 'noImage',
            'sprk-c-HighlightBoard__heading': true
          }"
        >
          {{ heading }}
        </h1>

        <sprk-stack
          sprkStackItem
          *ngIf="ctaText"
          itemSpacing="medium"
          splitAt="tiny"
          additionalClasses="sprk-o-Stack--center-column {{ centerBtns }}"
        >
          <div sprkStackItem class="sprk-c-HighlightBoard__cta">
            <a
              sprkLink
              variant="unstyled"
              [attr.href]="ctaHref"
              class="sprk-c-Button sprk-c-Button--primary sprk-c-Button--full@sm"
              [analyticsString]="analyticsStringCta"
            >
              {{ ctaText }}
            </a>
          </div>

          <div
            sprkStackItem
            *ngIf="ctaText2"
            class="sprk-c-HighlightBoard__cta"
          >
            <a
              sprkLink
              variant="unstyled"
              [attr.href]="ctaHref2"
              class="sprk-c-Button sprk-c-Button--secondary sprk-c-Button--full@sm"
              [analyticsString]="analyticsStringCta2"
            >
              {{ ctaText2 }}
            </a>
          </div>
        </sprk-stack>
      </sprk-stack>
    </div>
  `
    })
], SprkHighlightBoardComponent);

let SprkHighlightBoardModule = class SprkHighlightBoardModule {
};
SprkHighlightBoardModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            SprkStackModule,
            SprkStackItemModule,
            SprkLinkDirectiveModule
        ],
        declarations: [SprkHighlightBoardComponent],
        exports: [SprkHighlightBoardComponent]
    })
], SprkHighlightBoardModule);

let SprkBoxDirective = class SprkBoxDirective {
    /**
     * @ignore
     */
    constructor() { }
    get flush() {
        return this.spacing === 'flush';
    }
    get tiny() {
        return this.spacing === 'tiny';
    }
    get small() {
        return this.spacing === 'small';
    }
    get medium() {
        return this.spacing === 'medium';
    }
    get large() {
        return this.spacing === 'large';
    }
    get huge() {
        return this.spacing === 'huge';
    }
    get insetShortTiny() {
        return this.spacing === 'insetShortTiny';
    }
    get insetShortSmall() {
        return this.spacing === 'insetShortSmall';
    }
    get insetShortMedium() {
        return this.spacing === 'insetShortMedium';
    }
    get insetShortLarge() {
        return this.spacing === 'insetShortLarge';
    }
    get insetShortHuge() {
        return this.spacing === 'insetShortHuge';
    }
    get insetTallTiny() {
        return this.spacing === 'insetTallTiny';
    }
    get insetTallSmall() {
        return this.spacing === 'insetTallSmall';
    }
    get insetTallMedium() {
        return this.spacing === 'insetTallMedium';
    }
    get insetTallLarge() {
        return this.spacing === 'insetTallLarge';
    }
    get insetTallHuge() {
        return this.spacing === 'insetTallHuge';
    }
    get miscA() {
        return this.spacing === 'miscA';
    }
    get miscB() {
        return this.spacing === 'miscB';
    }
    get miscC() {
        return this.spacing === 'miscC';
    }
    get miscD() {
        return this.spacing === 'miscD';
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkBoxDirective.prototype, "spacing", void 0);
__decorate([
    HostBinding('class.sprk-o-Box'),
    __metadata("design:type", Object)
], SprkBoxDirective.prototype, "true", void 0);
__decorate([
    HostBinding('class.sprk-o-Box--flush'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "flush", null);
__decorate([
    HostBinding('class.sprk-o-Box--tiny'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "tiny", null);
__decorate([
    HostBinding('class.sprk-o-Box--small'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "small", null);
__decorate([
    HostBinding('class.sprk-o-Box--medium'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "medium", null);
__decorate([
    HostBinding('class.sprk-o-Box--large'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "large", null);
__decorate([
    HostBinding('class.sprk-o-Box--huge'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "huge", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-short-tiny'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetShortTiny", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-short-small'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetShortSmall", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-short-medium'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetShortMedium", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-short-large'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetShortLarge", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-short-huge'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetShortHuge", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-tall-tiny'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetTallTiny", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-tall-small'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetTallSmall", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-tall-medium'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetTallMedium", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-tall-large'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetTallLarge", null);
__decorate([
    HostBinding('class.sprk-o-Box--inset-tall-huge'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "insetTallHuge", null);
__decorate([
    HostBinding('class.sprk-o-Box--misc-a'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "miscA", null);
__decorate([
    HostBinding('class.sprk-o-Box--misc-b'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "miscB", null);
__decorate([
    HostBinding('class.sprk-o-Box--misc-c'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "miscC", null);
__decorate([
    HostBinding('class.sprk-o-Box--misc-d'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkBoxDirective.prototype, "miscD", null);
SprkBoxDirective = __decorate([
    Directive({
        selector: '[sprkBox]'
    }),
    __metadata("design:paramtypes", [])
], SprkBoxDirective);

let SprkBoxModule = class SprkBoxModule {
};
SprkBoxModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [SprkBoxDirective],
        exports: [SprkBoxDirective]
    })
], SprkBoxModule);

let SprkTextDirective = class SprkTextDirective {
    /**
     * @ignore
     */
    constructor() { }
    get textOne() {
        return this.variant === 'bodyOne';
    }
    get textTwo() {
        return this.variant === 'bodyTwo';
    }
    get textThree() {
        return this.variant === 'bodyThree';
    }
    get textFour() {
        return this.variant === 'bodyFour';
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkTextDirective.prototype, "variant", void 0);
__decorate([
    HostBinding('class.sprk-b-TypeBodyOne'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkTextDirective.prototype, "textOne", null);
__decorate([
    HostBinding('class.sprk-b-TypeBodyTwo'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkTextDirective.prototype, "textTwo", null);
__decorate([
    HostBinding('class.sprk-b-TypeBodyThree'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkTextDirective.prototype, "textThree", null);
__decorate([
    HostBinding('class.sprk-b-TypeBodyFour'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkTextDirective.prototype, "textFour", null);
SprkTextDirective = __decorate([
    Directive({
        selector: '[sprkText]'
    }),
    __metadata("design:paramtypes", [])
], SprkTextDirective);

let SprkTextModule = class SprkTextModule {
};
SprkTextModule = __decorate([
    NgModule({
        declarations: [SprkTextDirective],
        exports: [SprkTextDirective]
    })
], SprkTextModule);

let SprkHeadingDirective = class SprkHeadingDirective {
    /**
     * @ignore
     */
    constructor() {
        this.isPageTitle = false;
    }
    get headingOne() {
        return this.variant === 'displayOne';
    }
    get headingTwo() {
        return this.variant === 'displayTwo';
    }
    get headingThree() {
        return this.variant === 'displayThree';
    }
    get headingFour() {
        return this.variant === 'displayFour';
    }
    get headingFive() {
        return this.variant === 'displayFive';
    }
    get headingSix() {
        return this.variant === 'displaySix';
    }
    get headingSeven() {
        return this.variant === 'displaySeven';
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkHeadingDirective.prototype, "variant", void 0);
__decorate([
    HostBinding('class.sprk-b-TypeDisplayOne'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkHeadingDirective.prototype, "headingOne", null);
__decorate([
    HostBinding('class.sprk-b-TypeDisplayTwo'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkHeadingDirective.prototype, "headingTwo", null);
__decorate([
    HostBinding('class.sprk-b-TypeDisplayThree'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkHeadingDirective.prototype, "headingThree", null);
__decorate([
    HostBinding('class.sprk-b-TypeDisplayFour'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkHeadingDirective.prototype, "headingFour", null);
__decorate([
    HostBinding('class.sprk-b-TypeDisplayFive'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkHeadingDirective.prototype, "headingFive", null);
__decorate([
    HostBinding('class.sprk-b-TypeDisplaySix'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkHeadingDirective.prototype, "headingSix", null);
__decorate([
    HostBinding('class.sprk-b-TypeDisplaySeven'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SprkHeadingDirective.prototype, "headingSeven", null);
__decorate([
    HostBinding('class.sprk-b-PageTitle')
    /**
     * Value will be used to select
     * the heading style.
     */
    ,
    Input(),
    __metadata("design:type", Object)
], SprkHeadingDirective.prototype, "isPageTitle", void 0);
SprkHeadingDirective = __decorate([
    Directive({
        selector: '[sprkHeading]'
    }),
    __metadata("design:paramtypes", [])
], SprkHeadingDirective);

let SprkHeadingModule = class SprkHeadingModule {
};
SprkHeadingModule = __decorate([
    NgModule({
        declarations: [SprkHeadingDirective],
        exports: [SprkHeadingDirective]
    })
], SprkHeadingModule);

let SprkFlagComponent = class SprkFlagComponent {
    constructor() {
        /**
         * The Flag component will use this to decide where
         * the media-slot is rendered in relation to the
         * body-slot. The default is the media-slot is on
         * the left of the body-slot. isReversed="true" places the
         * media-slot on the right of the body-slot.
         */
        this.isReversed = false;
        /**
         * The Flag component will use this to stack
         * the element at the `$sprk-flag-stacked-breakpoint`
         */
        this.isStacked = false;
        /**
         * Determines how much space between the
         * media and the body.
         */
        this.spacing = 'medium';
        /**
         * Determines the vertical alignment of content.
         */
        this.verticalAlignment = 'top';
    }
    /**
     * @ignore
     */
    getClasses() {
        const classArray = ['sprk-o-Flag'];
        if (this.spacing !== 'medium') {
            const spacingClasses = {
                flush: 'sprk-o-Flag--flush',
                tiny: 'sprk-o-Flag--tiny',
                small: 'sprk-o-Flag--small',
                large: 'sprk-o-Flag--large',
                huge: 'sprk-o-Flag--huge',
            };
            classArray.push(spacingClasses[this.spacing]);
        }
        if (this.verticalAlignment !== 'top') {
            const verticalAlignmentClasses = {
                middle: 'sprk-o-Flag--middle',
                bottom: 'sprk-o-Flag--bottom',
            };
            classArray.push(verticalAlignmentClasses[this.verticalAlignment]);
        }
        if (this.isReversed) {
            classArray.push('sprk-o-Flag--rev');
        }
        if (this.isStacked) {
            classArray.push('sprk-o-Flag--stacked');
        }
        if (this.additionalClasses) {
            this.additionalClasses.split(' ').forEach(className => {
                classArray.push(className);
            });
        }
        return classArray.join(' ');
    }
    /**
     * @ignore
     */
    getMediaClasses() {
        const mediaClassArray = ['sprk-o-Flag__figure'];
        if (this.additionalMediaClasses) {
            this.additionalMediaClasses.split(' ').forEach(className => {
                mediaClassArray.push(className);
            });
        }
        return mediaClassArray.join(' ');
    }
    /**
     * @ignore
     */
    getBodyClasses() {
        const bodyClassArray = ['sprk-o-Flag__body'];
        if (this.additionalBodyClasses) {
            this.additionalBodyClasses.split(' ').forEach(className => {
                bodyClassArray.push(className);
            });
        }
        return bodyClassArray.join(' ');
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFlagComponent.prototype, "additionalClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFlagComponent.prototype, "additionalMediaClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFlagComponent.prototype, "additionalBodyClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFlagComponent.prototype, "idString", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkFlagComponent.prototype, "isReversed", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SprkFlagComponent.prototype, "isStacked", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFlagComponent.prototype, "spacing", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SprkFlagComponent.prototype, "verticalAlignment", void 0);
SprkFlagComponent = __decorate([
    Component({
        selector: 'sprk-flag',
        template: `
    <div
      [ngClass]="getClasses()"
      [attr.data-id]="idString"
    >
      <div [ngClass]="getMediaClasses()">
        <ng-content select="[media-slot]"></ng-content>
      </div>
      <div [ngClass]="getBodyClasses()">
        <ng-content select="[body-slot]"></ng-content>
      </div>
    </div>
  `
    })
], SprkFlagComponent);

let SprkFlagModule = class SprkFlagModule {
};
SprkFlagModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [SprkFlagComponent],
        exports: [SprkFlagComponent]
    })
], SprkFlagModule);

let SprkCenteredColumnDirective = class SprkCenteredColumnDirective {
};
__decorate([
    HostBinding('class.sprk-o-CenteredColumn'),
    __metadata("design:type", Object)
], SprkCenteredColumnDirective.prototype, "true", void 0);
__decorate([
    HostBinding('attr.data-id'),
    Input(),
    __metadata("design:type", String)
], SprkCenteredColumnDirective.prototype, "idString", void 0);
SprkCenteredColumnDirective = __decorate([
    Directive({
        selector: '[sprkCenteredColumn]'
    })
], SprkCenteredColumnDirective);

let SprkCenteredColumnModule = class SprkCenteredColumnModule {
};
SprkCenteredColumnModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [SprkCenteredColumnDirective],
        exports: [SprkCenteredColumnDirective]
    })
], SprkCenteredColumnModule);

if (typeof window !== 'undefined') {
    window['sprk'] = { version: { angular: environment.version } } || {};
}
let SparkAngularModule = class SparkAngularModule {
};
SparkAngularModule = __decorate([
    NgModule({
        exports: [
            SprkAlertModule,
            SprkAccordionModule,
            SprkAccordionItemModule,
            SprkAwardModule,
            SprkButtonModule,
            SprkCardModule,
            SprkDictionaryModule,
            SprkDividerModule,
            SprkDropdownModule,
            SprkLinkModule,
            SprkHighlightBoardModule,
            SprkModalModule,
            SprkOrderedListModule,
            SprkUnorderedListModule,
            SprkListItemModule,
            SparkInputContainerModule,
            SprkHugeInputContainerModule,
            SprkTextareaContainerModule,
            SprkIconInputContainerModule,
            SprkSelectionContainerModule,
            SprkSelectionItemContainerModule,
            SprkMastheadModule,
            SprkInputModule,
            SprkSelectionInputModule,
            SprkHelperTextModule,
            SprkLabelModule,
            SprkSelectionLabelModule,
            SprkFieldErrorModule,
            SprkFormatterPhoneNumberModule,
            SprkFormatterDateModule,
            SprkFormatterMonetaryModule,
            SprkFormatterSsnModule,
            SprkDatepickerModule,
            SprkPromoModule,
            SprkTableModule,
            SprkTableHeadModule,
            SprkTableGroupedColumnModule,
            SprkTableEmptyHeadingModule,
            SprkTableRowHeadingModule,
            SprkTabbedNavigationTabModule,
            SprkTabbedNavigationPanelModule,
            SprkPaginationModule,
            SprkStackModule,
            SprkStackItemModule,
            SprkToggleModule,
            SprkIconModule,
            SprkFooterModule,
            SprkTabbedNavigationModule,
            SprkBoxModule,
            SprkTextModule,
            SprkHeadingModule,
            SprkLinkDirectiveModule,
            SprkFlagModule,
            SprkCenteredColumnModule,
        ]
    })
], SparkAngularModule);

/*
 * Public API Surface of spark-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { SparkAngularModule, SparkInputContainerComponent, SparkInputContainerModule, SprkAccordionComponent, SprkAccordionItemComponent, SprkAccordionItemModule, SprkAccordionModule, SprkAlertComponent, SprkAlertModule, SprkAwardComponent, SprkAwardModule, SprkBoxDirective, SprkBoxModule, SprkButtonDirective, SprkButtonModule, SprkCardComponent, SprkCardModule, SprkCenteredColumnDirective, SprkCenteredColumnModule, SprkDatepickerDirective, SprkDatepickerModule, SprkDictionaryComponent, SprkDictionaryModule, SprkDividerComponent, SprkDividerModule, SprkDropdownComponent, SprkDropdownModule, SprkFieldErrorDirective, SprkFieldErrorModule, SprkFlagComponent, SprkFlagModule, SprkFooterComponent, SprkFooterModule, SprkFormatterDateDirective, SprkFormatterDateModule, SprkFormatterMonetaryDirective, SprkFormatterMonetaryModule, SprkFormatterPhoneNumberDirective, SprkFormatterPhoneNumberModule, SprkFormatterSsnDirective, SprkFormatterSsnModule, SprkHeadingDirective, SprkHeadingModule, SprkHelperTextDirective, SprkHelperTextModule, SprkHighlightBoardComponent, SprkHighlightBoardModule, SprkHugeInputContainerComponent, SprkHugeInputContainerModule, SprkIconComponent, SprkIconInputContainerComponent, SprkIconInputContainerModule, SprkIconModule, SprkInputDirective, SprkInputModule, SprkLabelDirective, SprkLabelModule, SprkLinkComponent, SprkLinkDirective, SprkLinkDirectiveModule, SprkLinkModule, SprkListItemComponent, SprkListItemModule, SprkMastheadAccordionComponent, SprkMastheadAccordionItemComponent, SprkMastheadAccordionItemModule, SprkMastheadAccordionModule, SprkMastheadComponent, SprkMastheadModule, SprkModalComponent, SprkModalModule, SprkOrderedListComponent, SprkOrderedListModule, SprkPaginationComponent, SprkPaginationModule, SprkPromoComponent, SprkPromoModule, SprkSelectionContainerComponent, SprkSelectionContainerModule, SprkSelectionInputDirective, SprkSelectionInputModule, SprkSelectionItemContainerComponent, SprkSelectionItemContainerModule, SprkSelectionLabelDirective, SprkSelectionLabelModule, SprkStackComponent, SprkStackItemDirective, SprkStackItemModule, SprkStackModule, SprkTabbedNavigationComponent, SprkTabbedNavigationModule, SprkTabbedNavigationPanelDirective, SprkTabbedNavigationPanelModule, SprkTabbedNavigationTabDirective, SprkTabbedNavigationTabModule, SprkTableComponent, SprkTableEmptyHeadingDirective, SprkTableEmptyHeadingModule, SprkTableGroupedColumnDirective, SprkTableGroupedColumnModule, SprkTableHeadDirective, SprkTableHeadModule, SprkTableModule, SprkTableRowHeadingDirective, SprkTableRowHeadingModule, SprkTextDirective, SprkTextModule, SprkTextareaContainerComponent, SprkTextareaContainerModule, SprkToggleComponent, SprkToggleModule, SprkUnorderedListComponent, SprkUnorderedListModule, toggleAnimations, SprkAlertModule as a, SprkIconModule as b, SprkDropdownModule as ba, SprkDropdownComponent as bb, SprkHighlightBoardModule as bc, SprkHighlightBoardComponent as bd, SprkModalModule as be, SprkModalComponent as bf, SprkOrderedListModule as bg, SprkOrderedListComponent as bh, SprkUnorderedListModule as bi, SprkUnorderedListComponent as bj, SprkListItemModule as bk, SprkListItemComponent as bl, SparkInputContainerModule as bm, SparkInputContainerComponent as bn, SprkLabelDirective as bo, SprkInputDirective as bp, SprkFieldErrorDirective as bq, SprkTextareaContainerModule as br, SprkTextareaContainerComponent as bs, SprkIconInputContainerModule as bt, SprkIconInputContainerComponent as bu, SprkSelectionContainerModule as bv, SprkSelectionContainerComponent as bw, SprkSelectionItemContainerComponent as bx, SprkSelectionLabelDirective as by, SprkSelectionInputDirective as bz, SprkIconComponent as c, SprkSelectionItemContainerModule as ca, SprkMastheadModule as cb, SprkMastheadAccordionModule as cc, SprkMastheadAccordionComponent as cd, SprkMastheadAccordionItemModule as ce, SprkMastheadAccordionItemComponent as cf, SprkMastheadComponent as cg, SprkInputModule as ch, SprkSelectionInputModule as ci, SprkHelperTextModule as cj, SprkHelperTextDirective as ck, SprkLabelModule as cl, SprkSelectionLabelModule as cm, SprkFieldErrorModule as cn, SprkFormatterPhoneNumberModule as co, SprkFormatterPhoneNumberDirective as cp, SprkFormatterDateModule as cq, SprkFormatterDateDirective as cr, SprkFormatterMonetaryModule as cs, SprkFormatterMonetaryDirective as ct, SprkFormatterSsnModule as cu, SprkFormatterSsnDirective as cv, SprkDatepickerModule as cw, SprkDatepickerDirective as cx, SprkPromoModule as cy, SprkPromoComponent as cz, SprkAlertComponent as d, SprkTableModule as da, SprkTableComponent as db, SprkTableHeadModule as dc, SprkTableHeadDirective as dd, SprkTableGroupedColumnModule as de, SprkTableGroupedColumnDirective as df, SprkTableEmptyHeadingModule as dg, SprkTableEmptyHeadingDirective as dh, SprkTableRowHeadingModule as di, SprkTableRowHeadingDirective as dj, SprkTabbedNavigationTabModule as dk, SprkTabbedNavigationTabDirective as dl, SprkTabbedNavigationPanelModule as dm, SprkTabbedNavigationPanelDirective as dn, SprkPaginationModule as do, SprkPaginationComponent as dp, SprkFooterModule as dq, SprkFooterComponent as dr, SprkTabbedNavigationModule as ds, SprkTabbedNavigationComponent as dt, SprkAccordionModule as e, SprkLinkModule as f, SprkLinkComponent as g, SprkAccordionComponent as h, SprkAccordionItemModule as i, SprkAccordionItemComponent as j, SprkAwardModule as k, SprkStackModule as l, SprkStackComponent as m, SprkStackItemModule as n, SprkStackItemDirective as o, SprkToggleModule as p, SprkToggleComponent as q, SprkAwardComponent as r, SprkButtonModule as s, SprkButtonDirective as t, SprkCardModule as u, SprkCardComponent as v, SprkDictionaryModule as w, SprkDictionaryComponent as x, SprkDividerModule as y, SprkDividerComponent as z };
//# sourceMappingURL=sparkdesignsystem-spark-angular.js.map
